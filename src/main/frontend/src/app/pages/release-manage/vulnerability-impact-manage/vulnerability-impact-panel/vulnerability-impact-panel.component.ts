import { Component, input, output, computed, signal, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { Vulnerability } from '../../../../services/vulnerability.service';
import { marked } from 'marked';

@Component({
  selector: 'app-vulnerability-impact-panel',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './vulnerability-impact-panel.component.html',
  styleUrl: './vulnerability-impact-panel.component.scss',
})
export class VulnerabilityImpactPanelComponent {
  public vulnerabilities = input.required<Vulnerability[]>();
  public selectedVulnerabilityId = input<string | null>(null);
  public searchQuery = input<string>('');

  public vulnerabilitySelected = output<Vulnerability>();
  public searchQueryChanged = output<string>();

  public expandedVulnerabilities = signal<Set<string>>(new Set());

  // eslint-disable-next-line unicorn/consistent-function-scoping
  public filteredVulnerabilities = computed(() => {
    const query = this.searchQuery().toLowerCase().trim();
    let vulns = this.vulnerabilities();

    if (query) {
      vulns = vulns.filter((v) => v.cveId.toLowerCase().includes(query) || v.description.toLowerCase().includes(query));
    }

    return [...vulns].toSorted((a, b) => {
      const severityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3, NONE: 4, UNKNOWN: 5 };
      const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];

      if (severityDiff !== 0) {
        return severityDiff;
      }

      return (b.cvssScore || 0) - (a.cvssScore || 0);
    });
  });

  private sanitizer = inject(DomSanitizer);

  public updateSearchQuery(event: Event): void {
    const query = (event.target as HTMLInputElement).value;
    this.searchQueryChanged.emit(query);
  }

  public toggleExpanded(event: Event, cveId: string): void {
    event.stopPropagation();
    const expanded = new Set(this.expandedVulnerabilities());
    if (expanded.has(cveId)) {
      expanded.delete(cveId);
    } else {
      expanded.add(cveId);
    }
    this.expandedVulnerabilities.set(expanded);
  }

  public isExpanded(cveId: string): boolean {
    return this.expandedVulnerabilities().has(cveId);
  }

  public selectVulnerability(vulnerability: Vulnerability): void {
    this.vulnerabilitySelected.emit(vulnerability);
  }

  public isSelected(cveId: string): boolean {
    return this.selectedVulnerabilityId() === cveId;
  }

  public getSeverityClass(severity: string): string {
    return `severity-${severity.toLowerCase()}`;
  }

  public getMarkdownHtml(markdown: string): SafeHtml {
    const html = marked(markdown);
    const htmlWithTarget = (html as string).replaceAll('<a ', '<a target="_blank" rel="noopener noreferrer" ');
    return this.sanitizer.bypassSecurityTrustHtml(htmlWithTarget);
  }

  public getCweUrl(cwe: string): string {
    const cweNumber = cwe.match(/\d+/)?.[0];
    return cweNumber ? `https://cwe.mitre.org/data/definitions/${cweNumber}.html` : '#';
  }
}
