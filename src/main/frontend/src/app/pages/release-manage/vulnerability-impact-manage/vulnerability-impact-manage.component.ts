import { Component, OnInit, inject, signal, computed } from '@angular/core';
import { CommonModule, Location } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Vulnerability, VulnerabilityService, VulnerabilityImpact } from '../../../services/vulnerability.service';
import { catchError, of } from 'rxjs';

@Component({
  selector: 'app-vulnerability-impact-manage',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule],
  templateUrl: './vulnerability-impact-manage.component.html',
  styleUrl: './vulnerability-impact-manage.component.scss',
})
export class VulnerabilityImpactManageComponent implements OnInit {
  public vulnerabilities = signal<Vulnerability[]>([]);
  public selectedVulnerability = signal<Vulnerability | null>(null);
  public isLoading = signal<boolean>(true);
  public isSaving = signal<boolean>(false);
  public vulnerabilitySearchQuery = signal<string>('');

  public impactForm!: FormGroup;

  public filteredVulnerabilities = computed(() => {
    const query = this.vulnerabilitySearchQuery().toLowerCase().trim();
    let vulns = this.vulnerabilities();

    if (query) {
      vulns = vulns.filter((v) =>
        v.cveId.toLowerCase().includes(query) ||
        v.description.toLowerCase().includes(query)
      );
    }

    return [...vulns].sort((a, b) => {
      const severityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3, NONE: 4, UNKNOWN: 5 };
      return severityOrder[a.severity] - severityOrder[b.severity];
    });
  });

  public hasImpact = computed(() => {
    const vuln = this.selectedVulnerability();
    return vuln && (vuln.impactScore !== undefined && vuln.impactScore !== null);
  });

  private vulnerabilityService = inject(VulnerabilityService);
  private fb = inject(FormBuilder);
  private location = inject(Location);

  ngOnInit(): void {
    this.initializeForm();
    this.fetchVulnerabilities();
  }

  public goBack(): void {
    this.location.back();
  }

  public updateVulnerabilitySearchQuery(query: string): void {
    this.vulnerabilitySearchQuery.set(query);
  }

  public selectVulnerability(vulnerability: Vulnerability): void {
    if (this.selectedVulnerability()?.cveId === vulnerability.cveId) {
      this.selectedVulnerability.set(null);
      this.resetForm();
    } else {
      this.selectedVulnerability.set(vulnerability);
      this.populateForm(vulnerability);
    }
  }

  public saveImpact(): void {
    if (this.impactForm.invalid || !this.selectedVulnerability()) return;

    this.isSaving.set(true);
    const vuln = this.selectedVulnerability()!;
    const formValue = this.impactForm.value;

    const impact: VulnerabilityImpact = {
      impactScore: formValue.impactScore,
      impactDescription: formValue.impactDescription,
    };

    this.vulnerabilityService.updateVulnerabilityImpact(vuln.cveId, impact).subscribe({
      next: (updatedVuln) => {
        const updatedList = this.vulnerabilities().map((v) =>
          v.cveId === updatedVuln.cveId ? updatedVuln : v
        );
        this.vulnerabilities.set(updatedList);
        this.selectedVulnerability.set(updatedVuln);
        this.populateForm(updatedVuln);
        this.isSaving.set(false);
      },
      error: (error) => {
        console.error('Failed to save impact:', error);
        this.isSaving.set(false);
      },
    });
  }

  public deleteImpact(): void {
    if (!this.selectedVulnerability()) return;

    this.isSaving.set(true);
    const vuln = this.selectedVulnerability()!;

    const impact: VulnerabilityImpact = {
      impactScore: null,
      impactDescription: null,
    };

    this.vulnerabilityService.updateVulnerabilityImpact(vuln.cveId, impact).subscribe({
      next: (updatedVuln) => {
        const updatedList = this.vulnerabilities().map((v) =>
          v.cveId === updatedVuln.cveId ? updatedVuln : v
        );
        this.vulnerabilities.set(updatedList);
        this.selectedVulnerability.set(updatedVuln);
        this.populateForm(updatedVuln);
        this.isSaving.set(false);
      },
      error: (error) => {
        console.error('Failed to delete impact:', error);
        this.isSaving.set(false);
      },
    });
  }

  public getSeverityClass(severity: string): string {
    return `severity-${severity.toLowerCase()}`;
  }

  private initializeForm(): void {
    this.impactForm = this.fb.group({
      impactScore: [null, [Validators.required, Validators.min(0), Validators.max(10)]],
      impactDescription: ['', [Validators.required, Validators.minLength(1), Validators.maxLength(1000)]],
    });
  }

  private resetForm(): void {
    this.impactForm.reset();
  }

  private populateForm(vulnerability: Vulnerability): void {
    this.impactForm.patchValue({
      impactScore: vulnerability.impactScore ?? null,
      impactDescription: vulnerability.impactDescription ?? '',
    });
  }

  private fetchVulnerabilities(): void {
    this.isLoading.set(true);
    this.vulnerabilityService
      .getAllVulnerabilities()
      .pipe(catchError(() => of([])))
      .subscribe({
        next: (vulnerabilities) => {
          this.vulnerabilities.set(vulnerabilities);
          this.isLoading.set(false);
        },
        error: () => {
          this.isLoading.set(false);
        },
      });
  }
}
