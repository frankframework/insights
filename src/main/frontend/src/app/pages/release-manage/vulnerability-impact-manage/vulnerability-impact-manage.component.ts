import { Component, OnInit, inject, signal } from '@angular/core';
import { CommonModule, Location } from '@angular/common';
import { Vulnerability, VulnerabilityService, VulnerabilityImpact } from '../../../services/vulnerability.service';
import { catchError, of } from 'rxjs';
import { LoaderComponent } from '../../../components/loader/loader.component';
import { VulnerabilityImpactPanelComponent } from './vulnerability-impact-panel/vulnerability-impact-panel.component';
import { VulnerabilityImpactDetailsComponent } from './vulnerability-impact-details/vulnerability-impact-details.component';

@Component({
  selector: 'app-vulnerability-impact-manage',
  standalone: true,
  imports: [CommonModule, LoaderComponent, VulnerabilityImpactPanelComponent, VulnerabilityImpactDetailsComponent],
  templateUrl: './vulnerability-impact-manage.component.html',
  styleUrl: './vulnerability-impact-manage.component.scss',
})
export class VulnerabilityImpactManageComponent implements OnInit {
  public vulnerabilities = signal<Vulnerability[]>([]);
  public selectedVulnerability = signal<Vulnerability | null>(null);
  public isLoading = signal<boolean>(true);
  public isSaving = signal<boolean>(false);
  public vulnerabilitySearchQuery = signal<string>('');

  private vulnerabilityService = inject(VulnerabilityService);
  private location = inject(Location);

  ngOnInit(): void {
    this.fetchVulnerabilities();
  }

  public goBack(): void {
    this.location.back();
  }

  public onSearchQueryChanged(query: string): void {
    this.vulnerabilitySearchQuery.set(query);
  }

  public onVulnerabilitySelected(vulnerability: Vulnerability): void {
    if (this.selectedVulnerability()?.cveId === vulnerability.cveId) {
      this.selectedVulnerability.set(null);
    } else {
      this.selectedVulnerability.set(vulnerability);
    }
  }

  public onImpactSaved(impact: VulnerabilityImpact): void {
    const vuln = this.selectedVulnerability();
    if (!vuln) return;

    this.isSaving.set(true);

    this.vulnerabilityService.updateVulnerabilityImpact(vuln.cveId, impact).subscribe({
      next: (updatedVuln) => {
        const updatedList = this.vulnerabilities().map((v) => (v.cveId === updatedVuln.cveId ? updatedVuln : v));
        this.vulnerabilities.set(updatedList);
        this.selectedVulnerability.set(updatedVuln);
        this.isSaving.set(false);
      },
      error: (error) => {
        console.error('Failed to save impact:', error);
        this.isSaving.set(false);
      },
    });
  }

  public onImpactDeleted(): void {
    const vuln = this.selectedVulnerability();
    if (!vuln) return;

    this.isSaving.set(true);

    this.vulnerabilityService.deleteVulnerabilityImpact(vuln.cveId).subscribe({
      next: () => {
        const vulnerabilityWithNullImpact = {
          ...vuln,
          impactScore: null,
          impactDescription: null,
        };

        const updatedList = this.vulnerabilities().map((v) =>
          v.cveId === vulnerabilityWithNullImpact.cveId ? vulnerabilityWithNullImpact : v,
        );
        this.vulnerabilities.set(updatedList);
        this.selectedVulnerability.set(vulnerabilityWithNullImpact);
        this.isSaving.set(false);
      },
      error: (error) => {
        console.error('Failed to delete impact:', error);
        this.isSaving.set(false);
      },
    });
  }

  private fetchVulnerabilities(): void {
    this.isLoading.set(true);
    this.vulnerabilityService
      .getAllVulnerabilities()
      .pipe(catchError(() => of([])))
      .subscribe({
        next: (vulnerabilities) => {
          this.vulnerabilities.set(vulnerabilities);
          this.isLoading.set(false);
        },
        error: () => {
          this.isLoading.set(false);
        },
      });
  }
}
