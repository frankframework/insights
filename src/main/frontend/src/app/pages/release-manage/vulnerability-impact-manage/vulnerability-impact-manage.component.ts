import { Component, OnInit, inject, signal, computed } from '@angular/core';
import { CommonModule, Location } from '@angular/common';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Vulnerability, VulnerabilityService, VulnerabilityImpact } from '../../../services/vulnerability.service';
import { catchError, of } from 'rxjs';
import { marked } from 'marked';
import { LoaderComponent } from '../../../components/loader/loader.component';

@Component({
  selector: 'app-vulnerability-impact-manage',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule, LoaderComponent],
  templateUrl: './vulnerability-impact-manage.component.html',
  styleUrl: './vulnerability-impact-manage.component.scss',
})
export class VulnerabilityImpactManageComponent implements OnInit {
  public vulnerabilities = signal<Vulnerability[]>([]);
  public selectedVulnerability = signal<Vulnerability | null>(null);
  public expandedVulnerabilities = signal<Set<string>>(new Set());
  public isLoading = signal<boolean>(true);
  public isSaving = signal<boolean>(false);
  public vulnerabilitySearchQuery = signal<string>('');
  public initialFormValue = signal<{ impactScore: number | null; impactDescription: string | null } | null>(null);

  public impactForm!: FormGroup;

  // eslint-disable-next-line unicorn/consistent-function-scoping
  public filteredVulnerabilities = computed(() => {
    const query = this.vulnerabilitySearchQuery().toLowerCase().trim();
    let vulns = this.vulnerabilities();

    if (query) {
      vulns = vulns.filter((v) => v.cveId.toLowerCase().includes(query) || v.description.toLowerCase().includes(query));
    }

    return [...vulns].toSorted((a, b) => {
      const severityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3, NONE: 4, UNKNOWN: 5 };
      const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];

      if (severityDiff !== 0) {
        return severityDiff;
      }

      return (b.cvssScore || 0) - (a.cvssScore || 0);
    });
  });

  // eslint-disable-next-line unicorn/consistent-function-scoping
  public hasImpact = computed(() => {
    const vuln = this.selectedVulnerability();
    return vuln && vuln.impactScore !== undefined && vuln.impactScore !== null;
  });

  private vulnerabilityService = inject(VulnerabilityService);
  private fb = inject(FormBuilder);
  private location = inject(Location);
  private sanitizer = inject(DomSanitizer);

  ngOnInit(): void {
    this.initializeForm();
    this.fetchVulnerabilities();
  }

  public goBack(): void {
    this.location.back();
  }

  public updateVulnerabilitySearchQuery(query: string): void {
    this.vulnerabilitySearchQuery.set(query);
  }

  public toggleExpanded(event: Event, cveId: string): void {
    event.stopPropagation();
    const expanded = new Set(this.expandedVulnerabilities());
    if (expanded.has(cveId)) {
      expanded.delete(cveId);
    } else {
      expanded.add(cveId);
    }
    this.expandedVulnerabilities.set(expanded);
  }

  public isExpanded(cveId: string): boolean {
    return this.expandedVulnerabilities().has(cveId);
  }

  public selectVulnerability(vulnerability: Vulnerability): void {
    if (this.selectedVulnerability()?.cveId === vulnerability.cveId) {
      this.selectedVulnerability.set(null);
      this.resetForm();
    } else {
      this.selectedVulnerability.set(vulnerability);
      this.populateForm(vulnerability);
    }
  }

  public saveImpact(): void {
    if (this.impactForm.invalid || !this.selectedVulnerability()) return;

    this.isSaving.set(true);
    const vuln = this.selectedVulnerability()!;
    const formValue = this.impactForm.value;

    const impact: VulnerabilityImpact = {
      impactScore: formValue.impactScore,
      impactDescription: formValue.impactDescription,
    };

    this.vulnerabilityService.updateVulnerabilityImpact(vuln.cveId, impact).subscribe({
      next: (updatedVuln) => {
        const updatedList = this.vulnerabilities().map((v) => (v.cveId === updatedVuln.cveId ? updatedVuln : v));
        this.vulnerabilities.set(updatedList);
        this.selectedVulnerability.set(updatedVuln);
        this.populateForm(updatedVuln);
        this.isSaving.set(false);
      },
      error: (error) => {
        console.error('Failed to save impact:', error);
        this.isSaving.set(false);
      },
    });
  }

  public deleteImpact(): void {
    if (!this.selectedVulnerability()) return;

    this.isSaving.set(true);
    const vuln = this.selectedVulnerability()!;

    this.vulnerabilityService.deleteVulnerabilityImpact(vuln.cveId).subscribe({
      next: () => {
        // Create updated vulnerability with null impact properties
        const vulnerabilityWithNullImpact = {
          ...vuln,
          impactScore: null,
          impactDescription: null,
        };

        const updatedList = this.vulnerabilities().map((v) =>
          v.cveId === vulnerabilityWithNullImpact.cveId ? vulnerabilityWithNullImpact : v,
        );
        this.vulnerabilities.set(updatedList);
        this.selectedVulnerability.set(vulnerabilityWithNullImpact);
        this.resetForm();
        this.isSaving.set(false);
      },
      error: (error) => {
        console.error('Failed to delete impact:', error);
        this.isSaving.set(false);
      },
    });
  }

  public getSeverityClass(severity: string): string {
    return `severity-${severity.toLowerCase()}`;
  }

  public isFormChanged(): boolean {
    const initial = this.initialFormValue();
    if (!initial || !this.impactForm) return false;

    const current = this.impactForm.value;
    return initial.impactScore !== current.impactScore || initial.impactDescription !== current.impactDescription;
  }

  public getMarkdownHtml(markdown: string): SafeHtml {
    const html = marked(markdown);
    const htmlWithTarget = (html as string).replaceAll('<a ', '<a target="_blank" rel="noopener noreferrer" ');
    return this.sanitizer.bypassSecurityTrustHtml(htmlWithTarget);
  }

  public getCweUrl(cwe: string): string {
    const cweNumber = cwe.match(/\d+/)?.[0];
    return cweNumber ? `https://cwe.mitre.org/data/definitions/${cweNumber}.html` : '#';
  }

  private initializeForm(): void {
    this.impactForm = this.fb.group({
      impactScore: [null, [Validators.required, Validators.min(0), Validators.max(10)]],
      impactDescription: ['', [Validators.required, Validators.minLength(1), Validators.maxLength(1000)]],
    });
  }

  private resetForm(): void {
    this.impactForm.reset();
    this.initialFormValue.set(null);
  }

  private populateForm(vulnerability: Vulnerability): void {
    const formValue = {
      impactScore: vulnerability.impactScore ?? null,
      impactDescription: vulnerability.impactDescription ?? '',
    };

    this.impactForm.patchValue(formValue);
    this.initialFormValue.set(formValue);
  }

  private fetchVulnerabilities(): void {
    this.isLoading.set(true);
    this.vulnerabilityService
      .getAllVulnerabilities()
      .pipe(catchError(() => of([])))
      .subscribe({
        next: (vulnerabilities) => {
          this.vulnerabilities.set(vulnerabilities);
          this.isLoading.set(false);
        },
        error: () => {
          this.isLoading.set(false);
        },
      });
  }
}
