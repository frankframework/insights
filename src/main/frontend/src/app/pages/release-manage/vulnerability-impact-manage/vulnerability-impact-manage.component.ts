import { Component, OnInit, inject, signal } from '@angular/core';
import { CommonModule, Location } from '@angular/common';
import { Vulnerability, VulnerabilityService, VulnerabilityImpact } from '../../../services/vulnerability.service';
import { catchError, finalize, of } from 'rxjs';
import { LoaderComponent } from '../../../components/loader/loader.component';
import { VulnerabilityImpactPanelComponent } from './vulnerability-impact-panel/vulnerability-impact-panel.component';
import { VulnerabilityImpactDetailsComponent } from './vulnerability-impact-details/vulnerability-impact-details.component';

@Component({
  selector: 'app-vulnerability-impact-manage',
  standalone: true,
  imports: [CommonModule, LoaderComponent, VulnerabilityImpactPanelComponent, VulnerabilityImpactDetailsComponent],
  templateUrl: './vulnerability-impact-manage.component.html',
  styleUrl: './vulnerability-impact-manage.component.scss',
})
export class VulnerabilityImpactManageComponent implements OnInit {
  public vulnerabilities = signal<Vulnerability[]>([]);
  public selectedVulnerability = signal<Vulnerability | null>(null);
  public isLoading = signal<boolean>(true);
  public isSaving = signal<boolean>(false);
  public vulnerabilitySearchQuery = signal<string>('');

  private vulnerabilityService = inject(VulnerabilityService);
  private location = inject(Location);

  ngOnInit(): void {
    this.fetchVulnerabilities();
  }

  public goBack(): void {
    this.location.back();
  }

  public onSearchQueryChanged(query: string): void {
    this.vulnerabilitySearchQuery.set(query);
  }

  public onVulnerabilitySelected(vulnerability: Vulnerability): void {
    if (this.selectedVulnerability()?.cveId === vulnerability.cveId) {
      this.selectedVulnerability.set(null);
    } else {
      this.selectedVulnerability.set(vulnerability);
    }
  }

  public onImpactSaved(impact: VulnerabilityImpact): void {
    const vuln = this.selectedVulnerability();
    if (!vuln) return;

    this.isSaving.set(true);

    this.vulnerabilityService
      .updateVulnerabilityImpact(vuln.cveId, impact)
      .pipe(finalize(() => this.isSaving.set(false)))
      .subscribe({
        next: (updatedVuln) => {
          const updatedList = this.vulnerabilities().map((v) => (v.cveId === updatedVuln.cveId ? updatedVuln : v));
          this.vulnerabilities.set(updatedList);
          this.selectedVulnerability.set(updatedVuln);
        },
        error: (error) => console.error('Failed to save impact:', error),
      });
  }

  public onImpactDeleted(): void {
    const vuln = this.selectedVulnerability();
    if (!vuln) return;

    this.isSaving.set(true);

    this.vulnerabilityService
      .deleteVulnerabilityImpact(vuln.cveId)
      .pipe(finalize(() => this.isSaving.set(false)))
      .subscribe({
        next: () => {
          const vulnerabilityWithNullImpact = {
            ...vuln,
            impactScore: null,
            impactDescription: null,
          };

          const updatedList = this.vulnerabilities().map((v) =>
            v.cveId === vulnerabilityWithNullImpact.cveId ? vulnerabilityWithNullImpact : v,
          );
          this.vulnerabilities.set(updatedList);
          this.selectedVulnerability.set(vulnerabilityWithNullImpact);
        },
        error: (error) => console.error('Failed to delete impact:', error),
      });
  }

  private fetchVulnerabilities(): void {
    this.isLoading.set(true);
    this.vulnerabilityService
      .getAllVulnerabilities()
      .pipe(
        catchError(() => of([])),
        finalize(() => this.isLoading.set(false)),
      )
      .subscribe((vulnerabilities) => this.vulnerabilities.set(vulnerabilities));
  }
}
