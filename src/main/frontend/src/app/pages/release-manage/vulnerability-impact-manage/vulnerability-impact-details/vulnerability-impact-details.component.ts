import {
  Component,
  input,
  output,
  computed,
  OnInit,
  OnChanges,
  SimpleChanges,
  inject,
  InputSignal,
  OutputEmitterRef,
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Vulnerability, VulnerabilityImpact } from '../../../../services/vulnerability.service';

@Component({
  selector: 'app-vulnerability-impact-details',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule],
  templateUrl: './vulnerability-impact-details.component.html',
  styleUrl: './vulnerability-impact-details.component.scss',
})
export class VulnerabilityImpactDetailsComponent implements OnInit, OnChanges {
  public vulnerability: InputSignal<Vulnerability | null> = input<Vulnerability | null>(null);
  public isSaving: InputSignal<boolean> = input<boolean>(false);

  public impactSaved: OutputEmitterRef<VulnerabilityImpact> = output<VulnerabilityImpact>();
  public impactDeleted: OutputEmitterRef<void> = output<void>();

  public impactForm!: FormGroup;
  public initialFormValue: { impactScore: number | null; impactDescription: string | null } | null = null;

  // eslint-disable-next-line unicorn/consistent-function-scoping
  public hasImpact = computed(() => {
    const vuln = this.vulnerability();
    return vuln && vuln.impactScore !== undefined && vuln.impactScore !== null;
  });

  private readonly fb: FormBuilder = inject(FormBuilder);

  ngOnInit(): void {
    this.initializeForm();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['vulnerability'] && this.impactForm) {
      const currentVuln = this.vulnerability();
      if (currentVuln) {
        this.populateForm(currentVuln);
      } else {
        this.resetForm();
      }
    }
  }

  public saveImpact(): void {
    if (this.impactForm.invalid) return;

    const formValue = this.impactForm.value;
    const impact: VulnerabilityImpact = {
      impactScore: formValue.impactScore,
      impactDescription: formValue.impactDescription,
    };

    this.impactSaved.emit(impact);
  }

  public deleteImpact(): void {
    this.impactDeleted.emit();
  }

  public isFormChanged(): boolean {
    if (!this.initialFormValue || !this.impactForm) return false;

    const current = this.impactForm.value;
    return (
      this.initialFormValue.impactScore !== current.impactScore ||
      this.initialFormValue.impactDescription !== current.impactDescription
    );
  }

  private initializeForm(): void {
    this.impactForm = this.fb.group({
      impactScore: [null, [Validators.required, Validators.min(0), Validators.max(10)]],
      impactDescription: ['', [Validators.required, Validators.minLength(1), Validators.maxLength(1000)]],
    });
  }

  private resetForm(): void {
    this.impactForm.reset();
    this.initialFormValue = null;
  }

  private populateForm(vulnerability: Vulnerability): void {
    const formValue = {
      impactScore: vulnerability.impactScore ?? null,
      impactDescription: vulnerability.impactDescription ?? '',
    };

    this.impactForm.patchValue(formValue);
    this.initialFormValue = formValue;
  }
}
