package org.frankframework.insights.vulnerability;

import jakarta.validation.Valid;
import java.util.Set;

import lombok.extern.slf4j.Slf4j;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/vulnerabilities")
@Slf4j
public class VulnerabilityController {
    private final VulnerabilityService vulnerabilityService;

    public VulnerabilityController(VulnerabilityService vulnerabilityService) {
        this.vulnerabilityService = vulnerabilityService;
    }

    /**
     * Fetches all vulnerabilities in the system.
     * Requires authentication.
     * @param principal The authenticated OAuth2 user
     * @return List of all vulnerabilities
     */
    @GetMapping
    public ResponseEntity<Set<VulnerabilityResponse>> getAllVulnerabilities(
            @AuthenticationPrincipal OAuth2User principal) {
        Set<VulnerabilityResponse> vulnerabilities = vulnerabilityService.getAllVulnerabilities();
        return ResponseEntity.status(HttpStatus.OK).body(vulnerabilities);
    }

    /**
     * Fetches all vulnerabilities associated with a given release ID.
     * @param releaseId The ID of the release to fetch vulnerabilities for
     * @return Set of vulnerabilities associated with the release
     */
    @GetMapping("/release/{releaseId}")
    public ResponseEntity<Set<VulnerabilityResponse>> getVulnerabilitiesByReleaseId(@PathVariable String releaseId) {
        Set<VulnerabilityResponse> vulnerabilities = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);
        return ResponseEntity.status(HttpStatus.OK).body(vulnerabilities);
    }

    /**
     * Updates a vulnerability with new impact score and description.
     * Requires authentication.
     * @param cveId The CVE ID of the vulnerability to update
     * @param vulnerabilityImpactRequest The request containing the updated impact information
     * @param principal The authenticated OAuth2 user
     * @return The updated vulnerability
     */
    @PutMapping("/{cveId}/impact")
    public ResponseEntity<VulnerabilityResponse> updateVulnerabilityImpact(
            @PathVariable String cveId,
            @Valid @RequestBody VulnerabilityImpactRequest vulnerabilityImpactRequest,
            @AuthenticationPrincipal OAuth2User principal) throws VulnerabilityNotFoundException {
        VulnerabilityResponse updatedVulnerability =
                vulnerabilityService.updateVulnerabilityImpact(cveId, vulnerabilityImpactRequest);
        return ResponseEntity.status(HttpStatus.OK).body(updatedVulnerability);
    }

	/**
	 * Deletes the impact properties of a vulnerability.
	 * @param cveId The CVE ID of the vulnerability
	 * @param principal The authenticated OAuth2 user
	 * @return No content response
	 * @throws VulnerabilityNotFoundException if the vulnerability is not found
	 */
	@DeleteMapping("/{cveId}/impact")
	public ResponseEntity<Void> deleteVulnerabilityImpact(
			@PathVariable String cveId, @AuthenticationPrincipal OAuth2User principal)
			throws VulnerabilityNotFoundException {
		vulnerabilityService.deleteVulnerabilityImpact(cveId);
		return ResponseEntity.noContent().build();
	}
}
