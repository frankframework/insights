package org.frankframework.insights.vulnerability;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Slf4j
public class VulnerabilityService {
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private static final long INITIAL_RETRY_DELAY_MS = 2000;
    private static final long SCAN_DELAY_MS = 5000;
    private static final int RETRY_BACKOFF_MULTIPLIER = 2;
    private static final String TRIVY_SKIP_FILES =
            "**/*.properties,**/*.sh,**/*.bat,**/*.java,**/*.ts,**/*.js,**/*.html,**/*.css,**/*.scss,**/*.xslt,**/*.rtf,**/*.md";
    private static final int TRIVY_TIMEOUT_MINUTES = 30;
    private static final int JSON_OUTPUT_PREVIEW_LENGTH = 500;
    private static final int EXIT_CODE_TIMEOUT = -1;

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ReleaseVulnerabilityRepository releaseVulnerabilityRepository;
    private final ReleaseRepository releaseRepository;
    private final ReleaseArtifactService releaseArtifactService;
    private final Mapper mapper;
    private final Object scanLock = new Object();

    private volatile boolean scanInProgress = false;

    @Value("${trivy.executable:trivy}")
    private String trivyExecutable;

    public VulnerabilityService(
            VulnerabilityRepository vulnerabilityRepository,
            ReleaseVulnerabilityRepository releaseVulnerabilityRepository,
            ReleaseRepository releaseRepository,
            ReleaseArtifactService releaseArtifactService,
            Mapper mapper) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.releaseVulnerabilityRepository = releaseVulnerabilityRepository;
        this.releaseRepository = releaseRepository;
        this.releaseArtifactService = releaseArtifactService;
        this.mapper = mapper;
    }

    /**
     * Main method: Scans all releases using Trivy CLI.
     * by calling the public @Transactional scanAndSaveVulnerabilitiesForSingleRelease method.
     * Note: Trivy scans are serialized (one at a time) to prevent database lock conflicts.
     * Only one scan process can run at a time across the entire application.
     */
    public void scanAndSaveVulnerabilitiesForAllReleases() {
        synchronized (scanLock) {
            if (scanInProgress) {
                log.warn("Vulnerability scan already in progress. Rejecting concurrent scan request.");
                return;
            }
            scanInProgress = true;
        }

        try {
            log.info(
                    "Starting vulnerability scan for all releases using Trivy CLI (scans will run sequentially to avoid database locks)...");
            List<Release> releases = releaseRepository.findAll();
            if (releases.isEmpty()) {
                log.warn("No releases found in database to scan.");
                return;
            }

            releases.sort(Comparator.comparing(Release::getName, Comparator.nullsLast(Comparator.naturalOrder())));
            log.info("Scanning {} releases in version order", releases.size());

            int totalLinksCreated = 0;
            int releasesScanned = 0;
            int releasesFailed = 0;

            for (Release release : releases) {
                String tag = release.getTagName();
                if (tag == null || tag.isBlank()) {
                    log.warn("Release {} ({}) has no tag name, skipping scan.", release.getName(), release.getId());
                    continue;
                }

                try {
                    int linksCreated = scanAndSaveVulnerabilitiesForSingleRelease(release);
                    totalLinksCreated += linksCreated;
                    releasesScanned++;

                    if (releasesScanned < releases.size()) {
                        sleepBetweenScans();
                    }
                } catch (Exception e) {
                    log.error("Failed to scan release {}: {}", tag, e.getMessage(), e);
                    releasesFailed++;
                    if (e instanceof InterruptedException) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }

            log.info(
                    "Vulnerability scan finished. Releases scanned: {}, Failed: {}, Links created: {}",
                    releasesScanned,
                    releasesFailed,
                    totalLinksCreated);
        } finally {
            synchronized (scanLock) {
                scanInProgress = false;
            }
            log.info("Vulnerability scan lock released.");
        }
    }

    /**
     * Adds a delay between consecutive release scans to prevent overwhelming the system
     * and reduce contention on shared resources like the Trivy database.
     *
     * @throws InterruptedException if the thread is interrupted during sleep
     */
    private void sleepBetweenScans() throws InterruptedException {
        Thread.sleep(SCAN_DELAY_MS);
    }

    /**
     * Prepares, scans, and saves vulnerabilities for a single release.
     *
     * @param release The release to scan
     * @return The number of vulnerability links created
     * @throws IOException, InterruptedException
     */
    public int scanAndSaveVulnerabilitiesForSingleRelease(Release release) throws IOException, InterruptedException {
        Path directoryToScan = releaseArtifactService.prepareReleaseArtifacts(release);
        log.info("Prepared artifacts for release {}. Scanning directory: {}", release.getName(), directoryToScan);

        TrivyReport report = runTrivyScan(directoryToScan);

        List<TrivyVulnerability> trivyVulnerabilities = parseVulnerabilitiesFromReport(report);

        return persistScanResults(release, trivyVulnerabilities);
    }

    /**
     * Retrieves vulnerabilities linked to a release ID.
     *
     * @param releaseId The ID of the release to fetch vulnerabilities for
     * @return Set of vulnerability response DTOs
     */
    @Transactional(readOnly = true)
    public Set<VulnerabilityResponse> getVulnerabilitiesByReleaseId(String releaseId) {
        if (releaseId == null || releaseId.isBlank()) {
            log.warn("Attempted to fetch vulnerabilities with null or blank release ID");
            return Collections.emptySet();
        }

        try {
            List<ReleaseVulnerability> links = releaseVulnerabilityRepository.findAllByReleaseId(releaseId);
            log.debug("Found {} vulnerability links for release {}", links.size(), releaseId);

            return links.stream()
                    .map(ReleaseVulnerability::getVulnerability)
                    .filter(Objects::nonNull)
                    .map(v -> mapper.toDTO(v, VulnerabilityResponse.class))
                    .collect(Collectors.toSet());
        } catch (Exception e) {
            log.error("Error fetching vulnerabilities for release {}: {}", releaseId, e.getMessage(), e);
            return Collections.emptySet();
        }
    }

    /**
     * Runs the Trivy scan with retry logic for database lock conflicts.
     * Synchronized to prevent concurrent Trivy scans (Trivy's DB doesn't support concurrent access).
     * Uses exponential backoff when database locks are detected.
     *
     * @return A valid TrivyReport (empty if no results).
     * @throws IOException, InterruptedException if the scan fails after all retries.
     */
    private synchronized TrivyReport runTrivyScan(Path directoryToScan) throws IOException, InterruptedException {
        log.debug("Running Trivy scan for directory: {}", directoryToScan);

        IOException lastException = null;
        long retryDelay = INITIAL_RETRY_DELAY_MS;

        for (int attempt = 1; attempt <= MAX_RETRY_ATTEMPTS; attempt++) {
            try {
                TrivyProcessResult result = executeTrivyProcess(directoryToScan);
                validateTrivyProcessResult(result, directoryToScan);
                TrivyReport report = parseTrivyOutput(result.output(), directoryToScan);

                if (attempt > 1) {
                    log.info("Trivy scan succeeded on attempt {}/{}", attempt, MAX_RETRY_ATTEMPTS);
                }

                return report;
            } catch (IOException e) {
                lastException = e;

                if (isDatabaseLockError(e)) {
                    if (attempt < MAX_RETRY_ATTEMPTS) {
                        log.warn(
                                "Trivy database lock detected (attempt {}/{}). Retrying in {}ms... Error: {}",
                                attempt,
                                MAX_RETRY_ATTEMPTS,
                                retryDelay,
                                e.getMessage());
                        this.wait(retryDelay);
                        retryDelay *= RETRY_BACKOFF_MULTIPLIER;
                    } else {
                        log.error(
                                "Trivy scan failed after {} attempts due to database lock. Error: {}",
                                MAX_RETRY_ATTEMPTS,
                                e.getMessage());
                    }
                } else {
                    throw e;
                }
            }
        }

        throw new IOException(
                "Trivy scan failed after " + MAX_RETRY_ATTEMPTS + " attempts. Last error: "
                        + lastException.getMessage(),
                lastException);
    }

    /**
     * Checks if an IOException is caused by a Trivy database lock.
     *
     * @param e The exception to check
     * @return true if the error is related to database locks
     */
    private boolean isDatabaseLockError(IOException e) {
        if (e == null || e.getMessage() == null) {
            return false;
        }
        String message = e.getMessage().toLowerCase();
        return message.contains("database may be in use")
                || message.contains("database lock")
                || message.contains("db error")
                || message.contains("database is locked");
    }

    /**
     * Helper method to encapsulate the ProcessBuilder logic for running Trivy.
     *
     * <p>Trivy CLI command structure:
     * <pre>
     * trivy fs                                    - Scan filesystem
     *   --format json                             - Output as JSON for parsing
     *   --quiet                                   - Suppress progress output
     *   --parallel 1                              - Limit parallelism to prevent database conflicts
     *   --scanners vuln                           - Only scan for vulnerabilities (not secrets/misconfigs)
     *   --skip-files "pattern"                    - Ignore files for trivy scan (.java .html .properties .ts .js .css .sh .bat)
     *   --timeout 15m                             - Maximum scan duration
     *   [directory]                               - Directory to scan
     * </pre>
     *
     * <p>Environment variables:
     * <ul>
     *   <li>GOMAXPROCS=1 - Limit Go runtime to single CPU core to reduce resource contention</li>
     *   <li>TRIVY_PARALLEL=1 - Limit Trivy's internal parallelism to prevent database lock conflicts</li>
     * </ul>
     *
     * @param directoryToScan The directory to scan.
     * @return A {@link TrivyProcessResult} containing the exit code and full string output.
     * @throws IOException, InterruptedException
     */
    private TrivyProcessResult executeTrivyProcess(Path directoryToScan) throws IOException, InterruptedException {
        ProcessBuilder processBuilder = new ProcessBuilder(
                this.trivyExecutable,
                "fs",
                "--format",
                "json",
                "--quiet",
                "--parallel",
                "1",
                "--scanners",
                "vuln",
                "--skip-files",
                String.join(",", TRIVY_SKIP_FILES),
                "--timeout",
                TRIVY_TIMEOUT_MINUTES + "m",
                directoryToScan.toString());
        processBuilder.redirectErrorStream(true);

        processBuilder.environment().put("GOMAXPROCS", "1");
        processBuilder.environment().put("TRIVY_PARALLEL", "1");

        log.info("Executing Trivy command: {}", String.join(" ", processBuilder.command()));

        Process process = processBuilder.start();
        String jsonOutput = readProcessOutput(process);

        boolean finished = process.waitFor(TRIVY_TIMEOUT_MINUTES, TimeUnit.MINUTES);
        if (!finished) {
            process.destroyForcibly();
            return new TrivyProcessResult(EXIT_CODE_TIMEOUT, "Process timed out.");
        }

        return new TrivyProcessResult(process.exitValue(), jsonOutput);
    }

    /**
     * Reads the entire output stream of a running process into a string.
     * @param process The process to read output from.
     * @return The full output as a string.
     * @throws IOException if an I/O error occurs.
     */
    private String readProcessOutput(Process process) throws IOException {
        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line);
            }
        }
        return output.toString();
    }

    /**
     * Validates the result of the Trivy process, throwing an exception if it failed or timed out.
     * @param result The result of the Trivy process.
     * @param directoryToScan The directory that was scanned (for logging).
     * @throws IOException if the process failed or timed out.
     */
    private void validateTrivyProcessResult(TrivyProcessResult result, Path directoryToScan) throws IOException {
        if (result.exitCode() == EXIT_CODE_TIMEOUT) {
            log.error(
                    "Trivy process timed out after {} minutes for directory: {}",
                    TRIVY_TIMEOUT_MINUTES,
                    directoryToScan);
            throw new IOException("Trivy scan timed out for " + directoryToScan);
        }

        if (result.exitCode() != 0) {
            log.error(
                    "Trivy scan FAILED for: {}, Exit code: {}, Trivy ouput: {}",
                    directoryToScan,
                    result.exitCode(),
                    result.output());
            throw new IOException(result.output());
        }
    }

    /**
     * Parses the JSON string output from Trivy into a TrivyReport object.
     * Handles empty or invalid JSON.
     * @param jsonOutput The JSON output from Trivy.
     * @param directoryToScan The directory that was scanned (for logging).
     * @return A TrivyReport object.
     * @throws IOException if parsing fails.
     */
    private TrivyReport parseTrivyOutput(String jsonOutput, Path directoryToScan) throws IOException {
        if (jsonOutput.isBlank()) {
            log.info("Trivy scan for {} produced empty output. No vulnerabilities found.", directoryToScan);
            return createEmptyTrivyReport();
        }

        try {
            return mapper.fromJson(jsonOutput, TrivyReport.class);
        } catch (Exception e) {
            log.error(
                    "Failed to parse Trivy JSON output for {}: {}. Output preview: {}",
                    directoryToScan,
                    e.getMessage(),
                    jsonOutput.length() > JSON_OUTPUT_PREVIEW_LENGTH
                            ? jsonOutput.substring(0, JSON_OUTPUT_PREVIEW_LENGTH) + "..."
                            : jsonOutput,
                    e);
            throw new IOException("Failed to parse Trivy JSON output", e);
        }
    }

    /**
     * Parses the list of vulnerabilities from a TrivyReport using streams.
     *
     * @param report The report from Trivy.
     * @return A List of {@link TrivyVulnerability} objects.
     */
    private List<TrivyVulnerability> parseVulnerabilitiesFromReport(TrivyReport report) {
        if (report.Results == null) {
            return Collections.emptyList();
        }
        return report.Results.stream()
                .filter(r -> r.Vulnerabilities() != null)
                .flatMap(r -> r.Vulnerabilities().stream())
                .filter(Objects::nonNull)
                .toList();
    }

    /**
     * Creates an empty TrivyReport object, used when a scan yields no output.
     * @return An empty TrivyReport instance.
     */
    private TrivyReport createEmptyTrivyReport() {
        TrivyReport emptyReport = new TrivyReport();
        emptyReport.Results = new ArrayList<>();
        return emptyReport;
    }

    /**
     * Orchestrates the persistence of scan results, handling empty results
     * or updating vulnerabilities and their links to the release.
     * @param release The release that was scanned
     * @param trivyVulnerabilities The list of vulnerabilities from Trivy
     * @return The number of vulnerability links created
     */
    private int persistScanResults(Release release, List<TrivyVulnerability> trivyVulnerabilities) {
        if (trivyVulnerabilities.isEmpty()) {
            return handleEmptyScanResult(release);
        }

        log.info(
                "Trivy scan completed for {}. Found {} results. Persisting...",
                release.getName(),
                trivyVulnerabilities.size());
        Set<Vulnerability> savedVulnerabilities = getOrCreateVulnerabilities(trivyVulnerabilities);
        return updateReleaseVulnerabilityLinks(release, savedVulnerabilities);
    }

    /**
     * Handles the case where no vulnerabilities were found.
     * It clears existing links for the release and returns 0.
     * @param release The release that was scanned
     * @return 0, since no links were created
     */
    private int handleEmptyScanResult(Release release) {
        log.info("Trivy scan completed for {}. No vulnerabilities found or report was empty.", release.getName());
        releaseVulnerabilityRepository.deleteAllByReleaseId(release.getId());
        return 0;
    }

    /**
     * Takes a list of Trivy vulnerabilities, finds existing ones in the DB,
     * creates new ones, updates all, and saves them in a batch.
     * @param trivyVulnerabilities The list of vulnerabilities from Trivy
     * @return The set of saved Vulnerability entities.
     */
    private Set<Vulnerability> getOrCreateVulnerabilities(List<TrivyVulnerability> trivyVulnerabilities) {
        Set<String> cveIdsInReport = getCveIdsFromReport(trivyVulnerabilities);
        Map<String, Vulnerability> existingVulnsMap = fetchExistingVulnerabilities(cveIdsInReport);
        Set<Vulnerability> vulnerabilitiesToSave = mapVulnerabilitiesToEntities(trivyVulnerabilities, existingVulnsMap);
        return saveVulnerabilityBatch(vulnerabilitiesToSave);
    }

    /**
     * Extracts all unique, non-null CVE IDs from a list of Trivy vulnerabilities.
     * @param trivyVulnerabilities The list of vulnerabilities from Trivy
     * @return A set of unique CVE IDs
     */
    private Set<String> getCveIdsFromReport(List<TrivyVulnerability> trivyVulnerabilities) {
        return trivyVulnerabilities.stream()
                .map(TrivyVulnerability::VulnerabilityID)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }

    /**
     * Fetches a Map of existing vulnerabilities from the database based on a set of CVE IDs.
     * @param cveIds The set of CVE IDs to look up.
     * @return A map ofCVE ID to Vulnerability entity.
     */
    private Map<String, Vulnerability> fetchExistingVulnerabilities(Set<String> cveIds) {
        return vulnerabilityRepository.findAllById(cveIds).stream()
                .collect(Collectors.toMap(Vulnerability::getCveId, v -> v));
    }

    /**
     * Maps a list of Trivy vulnerabilities to Vulnerability entities,
     * @param trivyVulnerabilities The list of vulnerabilities from Trivy
     * @param existingVulnsMap A map of existing vulnerabilities from the DB
     * @return A set of Vulnerability entities to save
     */
    private Set<Vulnerability> mapVulnerabilitiesToEntities(
            List<TrivyVulnerability> trivyVulnerabilities, Map<String, Vulnerability> existingVulnsMap) {
        return trivyVulnerabilities.stream()
                .map(tv -> mapTrivyVulnerabilityToEntity(tv, existingVulnsMap))
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }

    /**
     * Saves a batch of Vulnerability entities to the database.
     * @param vulnerabilitiesToSave The set of Vulnerability entities to save.
     * @return The set of saved Vulnerability entities.
     */
    private Set<Vulnerability> saveVulnerabilityBatch(Set<Vulnerability> vulnerabilitiesToSave) {
        List<Vulnerability> savedVulnerabilities = vulnerabilityRepository.saveAll(vulnerabilitiesToSave);
        return new HashSet<>(savedVulnerabilities);
    }

    /**
     * Clears all existing vulnerability links for a given release and
     * creates new links based on the provided set of vulnerabilities.
     *
     * @return The count of new links created.
     */
    private int updateReleaseVulnerabilityLinks(Release release, Set<Vulnerability> vulnerabilities) {
        log.debug("Clearing existing vulnerability links for release {}...", release.getName());
        releaseVulnerabilityRepository.deleteAllByReleaseId(release.getId());

        if (vulnerabilities.isEmpty()) {
            return 0;
        }

        log.info("Linking {} unique vulnerabilities to release {}", vulnerabilities.size(), release.getName());
        List<ReleaseVulnerability> newLinks = vulnerabilities.stream()
                .map(v -> createReleaseVulnerabilityLink(release, v))
                .toList();

        releaseVulnerabilityRepository.saveAll(newLinks);

        return newLinks.size();
    }

    /**
     * Creates a ReleaseVulnerability link entity between a release and a vulnerability.
     * @param release The release entity that the vulnerability is linked to.
     * @param vulnerability The vulnerability entity to link.
     * @return The created ReleaseVulnerability entity.
     */
    private ReleaseVulnerability createReleaseVulnerabilityLink(Release release, Vulnerability vulnerability) {
        ReleaseVulnerability link = new ReleaseVulnerability();
        link.setRelease(release);
        link.setVulnerability(vulnerability);
        return link;
    }

    /**
     * Maps a single TrivyVulnerability DTO to a Vulnerability entity.
     * This is the orchestrator for mapping a single vulnerability.
     *
     * @param trivyVulnerability The vulnerability data from Trivy
     * @param existingVulnerabilitiesMap A map of already-existing vulnerabilities from the DB
     * @return A new or updated (but unsaved) Vulnerability entity
     */
    private Vulnerability mapTrivyVulnerabilityToEntity(
            TrivyVulnerability trivyVulnerability, Map<String, Vulnerability> existingVulnerabilitiesMap) {
        if (trivyVulnerability == null || trivyVulnerability.VulnerabilityID() == null) {
            return null;
        }

        Vulnerability vulnerability =
                getOrCreateVulnerability(trivyVulnerability.VulnerabilityID(), existingVulnerabilitiesMap);

        vulnerability.setDescription(trivyVulnerability.buildDescription());
        vulnerability.setCwes(trivyVulnerability.getCweIdsAsSet());

        VulnerabilitySeverity severity = trivyVulnerability.toVulnerabilitySeverity();
        vulnerability.setSeverity(severity);
        vulnerability.setCvssScore(getEffectiveCvssScore(trivyVulnerability, severity, vulnerability.getCvssScore()));

        return vulnerability;
    }

    /**
     * Finds an existing Vulnerability by ID or creates a new one if not found.
     * @param vulnerabilityId The CVE ID of the vulnerability
     * @param existingVulnerabilitiesMap Map of existing vulnerabilities from the DB
     * @return The found or newly created Vulnerability entity
     */
    private Vulnerability getOrCreateVulnerability(
            String vulnerabilityId, Map<String, Vulnerability> existingVulnerabilitiesMap) {
        return existingVulnerabilitiesMap.computeIfAbsent(vulnerabilityId, id -> {
            Vulnerability newVulnerability = new Vulnerability();
            newVulnerability.setCveId(id);
            return newVulnerability;
        });
    }

    /**
     * Determines the effective CVSS score for a vulnerability.
     * Priority order:
     * 1. Score extracted from Trivy data
     * 2. Existing score in database
     * 3. Representative score based on severity
     *
     * @param trivyVulnerability The Trivy vulnerability DTO
     * @param severity The mapped VulnerabilitySeverity
     * @param existingScore The existing CVSS score in the DB (if any)
     * @return The effective CVSS score to set
     */
    private Double getEffectiveCvssScore(
            TrivyVulnerability trivyVulnerability, VulnerabilitySeverity severity, Double existingScore) {
        return trivyVulnerability
                .extractCvssScore()
                .or(() -> Optional.ofNullable(existingScore))
                .orElseGet(severity::getRepresentativeScore);
    }
}
