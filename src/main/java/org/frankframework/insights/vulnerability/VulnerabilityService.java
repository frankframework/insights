package org.frankframework.insights.vulnerability;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Optional;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.release.Release;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.utils.Settings;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Slf4j
public class VulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    public VulnerabilityService(
            VulnerabilityRepository vulnerabilityRepository,
            ReleaseVulnerabilityRepository releaseVulnerabilityRepository) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.releaseVulnerabilityRepository = releaseVulnerabilityRepository;
    }

    @Transactional
    public void scanRelease(Release release) {
        String cleanVersion = release.getName().replaceAll("^v", "");
        Optional<Path> dependencyPath = findDependencyArchive(cleanVersion);

        if (dependencyPath.isEmpty()) {
            log.warn("Archive not found for release {}, scan skipped", release.getName());
            return;
        }

        Path archivePath = dependencyPath.get();

        log.info("Starting OWASP vulnerability scan for release: {}", release.getName());

        try (Engine engine = new Engine(new Settings())) {
            engine.getSettings().setBoolean(Settings.KEYS.AUTO_UPDATE, true);
            engine.scan(archivePath.toFile());
            engine.analyzeDependencies();

            updateVulnerabilitiesForRelease(release, engine.getDependencies());
        } catch (Exception e) {
            log.error("OWASP vulnerability scan failed for release {}: {}", release.getName(), e.getMessage(), e);
            throw new RuntimeException("OWASP scan failed for " + release.getName(), e);
        }
        log.info("OWASP vulnerability scan completed for release: {}", release.getName());
    }

    private void updateVulnerabilitiesForRelease(
            Release release, org.owasp.dependencycheck.dependency.Dependency[] scannedDependencies) {
        releaseVulnerabilityRepository.deleteAllByRelease(release);

        for (org.owasp.dependencycheck.dependency.Dependency scannedDependency : scannedDependencies) {
            for (org.owasp.dependencycheck.dependency.Vulnerability scannedVulnerability :
                    scannedDependency.getVulnerabilities()) {
                Vulnerability vulnerability = vulnerabilityRepository
                        .findById(scannedVulnerability.getName())
                        .orElseGet(() -> {
                            Vulnerability newVulnerability = new Vulnerability();
                            newVulnerability.setCveId(scannedVulnerability.getName());
                            newVulnerability.setSeverity(VulnerabilitySeverity.valueOf(
                                    scannedVulnerability.getUnscoredSeverity().toUpperCase()));
                            newVulnerability.setCvssScore(
                                    scannedVulnerability.getCvssV3() != null
                                            ? scannedVulnerability.getCvssV3().getImpactScore()
                                            : Double.valueOf(0.0));
                            newVulnerability.setDescription(scannedVulnerability.getDescription());
                            newVulnerability.setCwes(
                                    scannedVulnerability.getCwes().getEntries());
                            return vulnerabilityRepository.save(newVulnerability);
                        });

                ReleaseVulnerability link = new ReleaseVulnerability(release, vulnerability);
                releaseVulnerabilityRepository.save(link);
            }
        }
    }

    private Optional<Path> findDependencyArchive(String cleanVersion) {
        Path dependencyArchiveDir = Paths.get("dependency-archive");

        // First try exact match
        Path exactPath = dependencyArchiveDir.resolve(cleanVersion);
        if (Files.exists(exactPath)) {
            log.debug("Found exact archive match for version: {}", cleanVersion);
            return Optional.of(exactPath);
        }

        // For nightly versions with timestamps, try wildcard matching
        // Pattern: version-yyyymmdd.* (e.g., 9.1.0-20250410.*)
        Pattern nightlyPattern = Pattern.compile("^(.+)-(\\d{8})\\.(\\d{6})$");
        if (nightlyPattern.matcher(cleanVersion).matches()) {
            String baseVersion = nightlyPattern.matcher(cleanVersion).replaceAll("$1");
            String datePrefix = nightlyPattern.matcher(cleanVersion).replaceAll("$2");

            try {
                return Files.list(dependencyArchiveDir)
                        .filter(Files::isDirectory)
                        .filter(path -> {
                            String dirName = path.getFileName().toString();
                            return dirName.startsWith(baseVersion + "-" + datePrefix + ".");
                        })
                        .findFirst();
            } catch (IOException e) {
                log.warn("Error while searching for wildcard match for version {}: {}", cleanVersion, e.getMessage());
            }
        }

        log.debug("No archive found for version: {}", cleanVersion);
        return Optional.empty();
    }
}
