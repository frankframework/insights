package org.frankframework.insights.vulnerability;

import io.github.jeremylong.openvulnerability.client.nvd.CvssV2;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV4;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.properties.NVDProperties;
import org.frankframework.insights.common.properties.OSSProperties;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;
import org.owasp.dependencycheck.exception.ExceptionCollection;
import org.owasp.dependencycheck.utils.Settings;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Slf4j
public class VulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ReleaseVulnerabilityRepository releaseVulnerabilityRepository;
    private final ReleaseRepository releaseRepository;
    private final ReleaseArtifactService releaseArtifactService;
    private final String ossIndexUsername;
    private final String ossIndexToken;
    private final String nvdApiKey;
    private final int nvdApiDelay;
	private static final int MAX_CVSS_ENTRY_SIZE = 255;

    public VulnerabilityService(
            VulnerabilityRepository vulnerabilityRepository,
            ReleaseVulnerabilityRepository releaseVulnerabilityRepository,
            ReleaseRepository releaseRepository,
            ReleaseArtifactService releaseArtifactService,
            OSSProperties ossProperties,
            NVDProperties nvdProperties) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.releaseVulnerabilityRepository = releaseVulnerabilityRepository;
        this.releaseRepository = releaseRepository;
        this.releaseArtifactService = releaseArtifactService;
        this.ossIndexUsername = ossProperties.getUsername();
        this.ossIndexToken = ossProperties.getToken();
        this.nvdApiKey = nvdProperties.getKey();
        this.nvdApiDelay = Integer.parseInt(nvdProperties.getDelay());
    }

	/**
	 * Executes a vulnerability scan for all releases in the database.
	 * This method is transactional to ensure database integrity during the scan process.
	 */
	@Transactional
    public void executeVulnerabilityScanForAllReleases() {
        List<Release> allReleases = releaseRepository.findAll();
        log.info("Starting full source code vulnerability scan for {} releases.", allReleases.size());

        int successCount = 0;
        int failCount = 0;

        for (Release release : allReleases) {
            try {
                Path releaseDir = releaseArtifactService.prepareReleaseArtifacts(release);
                scanDirectory(release, releaseDir);
                successCount++;
            } catch (Exception e) {
                failCount++;
                log.error("Failed to download or scan source for release {}: {}", release.getName(), e.getMessage(), e);
            }
        }
        log.info("Vulnerability scan process completed: {} releases succeeded, {} failed.", successCount, failCount);
    }

	/**
	 * Scans the specified project directory for vulnerabilities and updates the database.
	 * @param release The release associated with the project directory.
	 * @param projectDirectory The path to the project directory to scan.
	 */
	@Transactional
    public void scanDirectory(Release release, Path projectDirectory) {
        if (projectDirectory == null || !Files.isDirectory(projectDirectory)) {
            log.warn("Project directory is invalid or not found for release {}, scan skipped.", release.getName());
            return;
        }

        log.info(
                "Starting OWASP vulnerability scan for release: {} using directory: {}",
                release.getName(),
                projectDirectory);
        Settings settings = createOwaspSettings();

        try (Engine engine = new Engine(settings)) {
            try {
                engine.scan(projectDirectory.toFile());
                engine.analyzeDependencies();
            } catch (ExceptionCollection e) {
                log.warn(
                        "OWASP scan for release {} completed with non-fatal errors. Processing successful findings.",
                        release.getName());
                for (Throwable throwable : e.getExceptions()) {
                    log.warn("Non-fatal analysis error details: {}", throwable.getMessage());
                }
            }

            int vulnerabilityCount = countVulnerabilities(engine.getDependencies());
            log.info("Found {} vulnerabilities for release {}", vulnerabilityCount, release.getName());
            updateVulnerabilitiesForRelease(release, engine.getDependencies());

        } catch (Exception e) {
            log.error(
                    "A fatal OWASP vulnerability scan error occurred for release {}: {}",
                    release.getName(),
                    e.getMessage(),
                    e);
            throw new RuntimeException("OWASP scan failed for " + release.getName(), e);
        }

        log.info("OWASP vulnerability scan completed for release: {}", release.getName());
    }

	/**
	 * Creates and configures OWASP Dependency-Check settings.
	 * @return The configured Settings object.
	 */
    private Settings createOwaspSettings() {
        Settings settings = new Settings();
        settings.setBoolean(Settings.KEYS.AUTO_UPDATE, true);

        settings.setBoolean(Settings.KEYS.ANALYZER_OSSINDEX_ENABLED, true);

        if (ossIndexUsername != null
                && !ossIndexUsername.isBlank()
                && ossIndexToken != null
                && !ossIndexToken.isBlank()) {
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_USER, this.ossIndexUsername);
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD, this.ossIndexToken);
        } else {
            log.warn(
                    "Sonatype OSS Index credentials are not configured. The OSS Index Analyzer will fail to initialize.");
        }

        settings.setBoolean(Settings.KEYS.ANALYZER_CENTRAL_ENABLED, false);

        settings.setBoolean(Settings.KEYS.ANALYZER_JAR_ENABLED, true);
        settings.setBoolean(Settings.KEYS.ANALYZER_ARCHIVE_ENABLED, true);

        if (nvdApiKey != null && !nvdApiKey.isEmpty()) {
            settings.setString(Settings.KEYS.NVD_API_KEY, this.nvdApiKey);
            settings.setInt(Settings.KEYS.NVD_API_DELAY, this.nvdApiDelay);
        } else {
            log.warn("No NVD API key configured. Scanning will be rate-limited and slower.");
        }
        return settings;
    }

	/**
	 * Counts the total number of vulnerabilities across all dependencies.
	 * @param dependencies The array of dependencies to count vulnerabilities from.
	 * @return The total count of vulnerabilities.
	 */
    private int countVulnerabilities(Dependency[] dependencies) {
        if (dependencies == null) return 0;
        int count = 0;
        for (Dependency dep : dependencies) {
            count += dep.getVulnerabilities().size();
        }
        return count;
    }

	/**
	 * Updates the vulnerabilities associated with a release based on the scanned dependencies.
	 * @param release The release to update vulnerabilities for.
	 * @param scannedDependencies The dependencies scanned by OWASP containing vulnerability information.
	 */
    private void updateVulnerabilitiesForRelease(Release release, Dependency[] scannedDependencies) {
        releaseVulnerabilityRepository.deleteAllByRelease(release);
        int savedCount = 0;

        if (scannedDependencies == null) return;

        for (Dependency scannedDependency : scannedDependencies) {
            for (Vulnerability scannedVulnerability : scannedDependency.getVulnerabilities()) {
                try {
                    org.frankframework.insights.vulnerability.Vulnerability vulnerability = vulnerabilityRepository
                            .findById(scannedVulnerability.getName())
                            .orElseGet(() -> createAndSaveNewVulnerability(scannedVulnerability));
                    ReleaseVulnerability link = new ReleaseVulnerability(release, vulnerability);
                    releaseVulnerabilityRepository.save(link);
                    savedCount++;
                } catch (Exception e) {
                    log.error(
                            "Failed to save or link vulnerability {} for release {}: {}",
                            scannedVulnerability.getName(),
                            release.getName(),
                            e.getMessage());
                }
            }
        }
        log.info("Successfully linked {} vulnerabilities for release {}", savedCount, release.getName());
    }

	/**
	 * Creates and saves a new Vulnerability entity based on the scanned vulnerability details.
	 * @param scannedVulnerability The vulnerability from the OWASP scan.
	 * @return The saved Vulnerability entity.
	 */
    private org.frankframework.insights.vulnerability.Vulnerability createAndSaveNewVulnerability(
            Vulnerability scannedVulnerability) {
        org.frankframework.insights.vulnerability.Vulnerability newVulnerability =
                new org.frankframework.insights.vulnerability.Vulnerability();
        Double cvssScore = determineCvssScore(scannedVulnerability);
        newVulnerability.setCvssScore(cvssScore);

        if (cvssScore >= 0.0) {
            newVulnerability.setSeverity(VulnerabilitySeverity.fromScore(cvssScore));
        } else {
            newVulnerability.setSeverity(mapSeverityFromString(scannedVulnerability.getUnscoredSeverity()));
        }

        newVulnerability.setCveId(scannedVulnerability.getName());
        newVulnerability.setDescription(scannedVulnerability.getDescription());

        if (scannedVulnerability.getCwes() != null) {
            Set<String> cweEntries =
					scannedVulnerability.getCwes().getEntries().stream().limit(MAX_CVSS_ENTRY_SIZE).collect(Collectors.toSet());
            newVulnerability.setCwes(cweEntries);
        }
        return vulnerabilityRepository.save(newVulnerability);
    }

	/**
	 * Maps a severity string to the corresponding VulnerabilitySeverity enum.
	 * @param severity The severity string to map.
	 * @return The corresponding VulnerabilitySeverity, or UNKNOWN if not recognized.
	 */
    private VulnerabilitySeverity mapSeverityFromString(String severity) {
        if (severity == null || severity.isBlank()) {
            return VulnerabilitySeverity.UNKNOWN;
        }
        try {
            for (VulnerabilitySeverity s : VulnerabilitySeverity.values()) {
                if (s.name().equalsIgnoreCase(severity)) {
                    return s;
                }
            }
        } catch (IllegalArgumentException e) {
            log.warn("Unknown vulnerability severity string '{}', defaulting to UNKNOWN.", severity);
        }
        return VulnerabilitySeverity.UNKNOWN;
    }

    /**
     * Determines the most relevant CVSS score from a vulnerability, preferring v4.0, then v3.1, then v2.
     * This method is forward-compatible with future library updates that include CVSSv4.
     *
     * @param scannedVuln The vulnerability from the OWASP scan.
     * @return The determined CVSS score, or -1.0 if none is found.
     */
    private Double determineCvssScore(Vulnerability scannedVuln) {
        if (scannedVuln == null) {
            return -1.0;
        }

        CvssV4 cvssV4 = scannedVuln.getCvssV4();
        if (cvssV4 != null) {
			cvssV4.getCvssData();
			Double scoreV4 = cvssV4.getCvssData().getBaseScore();
			if (scoreV4 >= 0) {
				return scoreV4;
			}
		}

        CvssV3 cvssV3 = scannedVuln.getCvssV3();
        if (cvssV3 != null) {
			cvssV3.getCvssData();
			Double scoreV3 = cvssV3.getCvssData().getBaseScore();
			if (scoreV3 >= 0) {
				return scoreV3;
			}
		}

        CvssV2 cvssV2 = scannedVuln.getCvssV2();
        if (cvssV2 != null) {
			cvssV2.getCvssData();
			Double scoreV2 = cvssV2.getCvssData().getBaseScore();
			if (scoreV2 >= 0) {
				return scoreV2;
			}
		}

        return -1.0;
    }
}
