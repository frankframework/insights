package org.frankframework.insights.vulnerability;

import io.github.jeremylong.openvulnerability.client.nvd.CvssV2;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV4;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.properties.NVDProperties;
import org.frankframework.insights.common.properties.OSSProperties;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;
import org.owasp.dependencycheck.exception.ExceptionCollection;
import org.owasp.dependencycheck.utils.Settings;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Slf4j
public class VulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ReleaseVulnerabilityRepository releaseVulnerabilityRepository;
    private final ReleaseRepository releaseRepository;
    private final ReleaseArtifactService releaseArtifactService;
    private final String ossIndexUsername;
    private final String ossIndexToken;
    private final String nvdApiKey;
    private final int nvdApiDelay;
	private static final int MAX_CVSS_ENTRY_SIZE = 255;

    public VulnerabilityService(
            VulnerabilityRepository vulnerabilityRepository,
            ReleaseVulnerabilityRepository releaseVulnerabilityRepository,
            ReleaseRepository releaseRepository,
            ReleaseArtifactService releaseArtifactService,
            OSSProperties ossProperties,
            NVDProperties nvdProperties) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.releaseVulnerabilityRepository = releaseVulnerabilityRepository;
        this.releaseRepository = releaseRepository;
        this.releaseArtifactService = releaseArtifactService;
        this.ossIndexUsername = ossProperties.getUsername();
        this.ossIndexToken = ossProperties.getToken();
        this.nvdApiKey = nvdProperties.getKey();
        this.nvdApiDelay = nvdProperties.getDelay();
    }

	/**
	 * Executes a vulnerability scan for all releases in the database.
	 * Each release is scanned in its own transaction via scanDirectory().
	 */
	@Transactional
    public void executeVulnerabilityScanForAllReleases() {
        List<Release> allReleases = releaseRepository.findAll();
        log.info("Starting full source code vulnerability scan for {} releases.", allReleases.size());

		VulnerabilityScanDTO results = scanAllReleases(allReleases);

        log.info("Vulnerability scan process completed: {} releases succeeded, {} failed.",
                results.successCount(), results.failCount());
    }

    private VulnerabilityScanDTO scanAllReleases(List<Release> releases) {
        int successCount = 0;
        int failCount = 0;

        for (Release release : releases) {
            if (scanSingleRelease(release)) {
                successCount++;
            } else {
                failCount++;
            }
        }
        return new VulnerabilityScanDTO(successCount, failCount);
    }

    private boolean scanSingleRelease(Release release) {
        try {
            Path releaseDir = releaseArtifactService.prepareReleaseArtifacts(release);
            scanDirectory(release, releaseDir);
            return true;
        } catch (VulnerabilityScanException | IOException e) {
            log.error("Failed to download or scan source for release {}: {}", release.getName(), e.getMessage(), e);
            return false;
        }
    }

	/**
	 * Scans the specified project directory for vulnerabilities and updates the database.
	 * @param release The release associated with the project directory.
	 * @param projectDirectory The path to the project directory to scan.
	 * @throws VulnerabilityScanException if the scan encounters a fatal error.
	 */
    private void scanDirectory(Release release, Path projectDirectory) throws VulnerabilityScanException {
        if (!isValidProjectDirectory(projectDirectory, release)) {
            return;
        }

        log.info("Starting OWASP vulnerability scan for release: {} using directory: {}",
                release.getName(), projectDirectory);

        Settings settings = createOwaspSettings();
        executeScanWithEngine(release, projectDirectory, settings);

        log.info("OWASP vulnerability scan completed for release: {}", release.getName());
    }

    private boolean isValidProjectDirectory(Path projectDirectory, Release release) {
        if (projectDirectory == null || !Files.isDirectory(projectDirectory)) {
            log.warn("Project directory is invalid or not found for release {}, scan skipped.", release.getName());
            return false;
        }
        return true;
    }

    private void executeScanWithEngine(Release release, Path projectDirectory, Settings settings)
            throws VulnerabilityScanException {
        try (Engine engine = new Engine(settings)) {
            performScan(engine, projectDirectory, release);
            processScanResults(engine, release);
        } catch (Exception e) {
            handleFatalScanError(release, e);
        }
    }

    private void performScan(Engine engine, Path projectDirectory, Release release) {
        try {
            engine.scan(projectDirectory.toFile());
            engine.analyzeDependencies();
        } catch (ExceptionCollection e) {
            handleNonFatalErrors(release, e);
        }
    }

    private void handleNonFatalErrors(Release release, ExceptionCollection e) {
        log.warn("OWASP scan for release {} completed with non-fatal errors. Processing successful findings.",
                release.getName());
        for (Throwable throwable : e.getExceptions()) {
            log.warn("Non-fatal analysis error details: {}", throwable.getMessage());
        }
    }

    private void processScanResults(Engine engine, Release release) {
        int vulnerabilityCount = countVulnerabilities(engine.getDependencies());
        log.info("Found {} vulnerabilities for release {}", vulnerabilityCount, release.getName());
        updateVulnerabilitiesForRelease(release, engine.getDependencies());
    }

    private void handleFatalScanError(Release release, Exception e) throws VulnerabilityScanException {
        log.error("A fatal OWASP vulnerability scan error occurred for release {}: {}",
                release.getName(), e.getMessage(), e);
        throw new VulnerabilityScanException("OWASP scan failed for " + release.getName(), e);
    }

	/**
	 * Creates and configures OWASP Dependency-Check settings.
	 * @return The configured Settings object.
	 */
    private Settings createOwaspSettings() {
        Settings settings = new Settings();
        settings.setBoolean(Settings.KEYS.AUTO_UPDATE, true);

        configureOssIndexAnalyzer(settings);
        configureBasicAnalyzers(settings);
        configureNvdApi(settings);

        return settings;
    }

    private void configureOssIndexAnalyzer(Settings settings) {
        settings.setBoolean(Settings.KEYS.ANALYZER_OSSINDEX_ENABLED, true);

        if (hasValidOssIndexCredentials()) {
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_USER, this.ossIndexUsername);
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD, this.ossIndexToken);
        } else {
            log.warn("Sonatype OSS Index credentials are not configured. The OSS Index Analyzer will fail to initialize.");
        }
    }

    private boolean hasValidOssIndexCredentials() {
        return ossIndexUsername != null && !ossIndexUsername.isBlank()
                && ossIndexToken != null && !ossIndexToken.isBlank();
    }

    private void configureBasicAnalyzers(Settings settings) {
        settings.setBoolean(Settings.KEYS.ANALYZER_CENTRAL_ENABLED, false);
        settings.setBoolean(Settings.KEYS.ANALYZER_JAR_ENABLED, true);
        settings.setBoolean(Settings.KEYS.ANALYZER_ARCHIVE_ENABLED, true);
    }

    private void configureNvdApi(Settings settings) {
        if (nvdApiKey != null && !nvdApiKey.isEmpty()) {
            settings.setString(Settings.KEYS.NVD_API_KEY, this.nvdApiKey);
            settings.setInt(Settings.KEYS.NVD_API_DELAY, this.nvdApiDelay);
        } else {
            log.warn("No NVD API key configured. Scanning will be rate-limited and slower.");
        }
    }

	/**
	 * Counts the total number of vulnerabilities across all dependencies.
	 * @param dependencies The array of dependencies to count vulnerabilities from.
	 * @return The total count of vulnerabilities.
	 */
    private int countVulnerabilities(Dependency[] dependencies) {
        if (dependencies == null) return 0;
        int count = 0;
        for (Dependency dep : dependencies) {
            count += dep.getVulnerabilities().size();
        }
        return count;
    }

	/**
	 * Updates the vulnerabilities associated with a release based on the scanned dependencies.
	 * @param release The release to update vulnerabilities for.
	 * @param scannedDependencies The dependencies scanned by OWASP containing vulnerability information.
	 */
    private void updateVulnerabilitiesForRelease(Release release, Dependency[] scannedDependencies) {
        releaseVulnerabilityRepository.deleteAllByRelease(release);

        if (scannedDependencies == null) {
            return;
        }

        int savedCount = processAllVulnerabilities(release, scannedDependencies);
        log.info("Successfully linked {} vulnerabilities for release {}", savedCount, release.getName());
    }

    private int processAllVulnerabilities(Release release, Dependency[] scannedDependencies) {
        int savedCount = 0;
        for (Dependency scannedDependency : scannedDependencies) {
            savedCount += processVulnerabilitiesForDependency(release, scannedDependency);
        }
        return savedCount;
    }

    private int processVulnerabilitiesForDependency(Release release, Dependency scannedDependency) {
        int savedCount = 0;
        for (Vulnerability scannedVulnerability : scannedDependency.getVulnerabilities()) {
            if (linkVulnerabilityToRelease(release, scannedVulnerability)) {
                savedCount++;
            }
        }
        return savedCount;
    }

    private boolean linkVulnerabilityToRelease(Release release, Vulnerability scannedVulnerability) {
        try {
            org.frankframework.insights.vulnerability.Vulnerability vulnerability = getOrCreateVulnerability(scannedVulnerability);
            ReleaseVulnerability link = new ReleaseVulnerability(release, vulnerability);
            releaseVulnerabilityRepository.save(link);
            return true;
        } catch (Exception e) {
            log.error("Failed to save or link vulnerability {} for release {}: {}",
                    scannedVulnerability.getName(), release.getName(), e.getMessage());
            return false;
        }
    }

    private org.frankframework.insights.vulnerability.Vulnerability getOrCreateVulnerability(Vulnerability scannedVulnerability) {
        return vulnerabilityRepository
                .findById(scannedVulnerability.getName())
                .orElseGet(() -> createAndSaveNewVulnerability(scannedVulnerability));
    }

	/**
	 * Creates and saves a new Vulnerability entity based on the scanned vulnerability details.
	 * @param scannedVulnerability The vulnerability from the OWASP scan.
	 * @return The saved Vulnerability entity.
	 */
    private org.frankframework.insights.vulnerability.Vulnerability createAndSaveNewVulnerability(
            Vulnerability scannedVulnerability) {
        org.frankframework.insights.vulnerability.Vulnerability newVulnerability =
                new org.frankframework.insights.vulnerability.Vulnerability();

        populateVulnerabilityScore(newVulnerability, scannedVulnerability);
        populateVulnerabilityBasicInfo(newVulnerability, scannedVulnerability);
        populateCweEntries(newVulnerability, scannedVulnerability);

        return vulnerabilityRepository.save(newVulnerability);
    }

    private void populateVulnerabilityScore(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        Double cvssScore = determineCvssScore(scannedVulnerability);
        newVulnerability.setCvssScore(cvssScore);

        if (cvssScore >= 0.0) {
            newVulnerability.setSeverity(VulnerabilitySeverity.fromScore(cvssScore));
        } else {
            newVulnerability.setSeverity(mapSeverityFromString(scannedVulnerability.getUnscoredSeverity()));
        }
    }

    private void populateVulnerabilityBasicInfo(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        newVulnerability.setCveId(scannedVulnerability.getName());
        newVulnerability.setDescription(scannedVulnerability.getDescription());
    }

    private void populateCweEntries(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        if (scannedVulnerability.getCwes() != null) {
            Set<String> cweEntries = scannedVulnerability.getCwes().getEntries().stream()
                    .limit(MAX_CVSS_ENTRY_SIZE)
                    .collect(Collectors.toSet());
            newVulnerability.setCwes(cweEntries);
        }
    }

	/**
	 * Maps a severity string to the corresponding VulnerabilitySeverity enum.
	 * @param severity The severity string to map.
	 * @return The corresponding VulnerabilitySeverity, or UNKNOWN if not recognized.
	 */
    private VulnerabilitySeverity mapSeverityFromString(String severity) {
        if (severity == null || severity.isBlank()) {
            return VulnerabilitySeverity.UNKNOWN;
        }
        try {
            for (VulnerabilitySeverity s : VulnerabilitySeverity.values()) {
                if (s.name().equalsIgnoreCase(severity)) {
                    return s;
                }
            }
        } catch (IllegalArgumentException e) {
            log.warn("Unknown vulnerability severity string '{}', defaulting to UNKNOWN.", severity);
        }
        return VulnerabilitySeverity.UNKNOWN;
    }

    /**
     * Determines the most relevant CVSS score from a vulnerability, preferring v4.0, then v3.1, then v2.
     * This method is forward-compatible with future library updates that include CVSSv4.
     *
     * @param scannedVulnerability The vulnerability from the OWASP scan.
     * @return The determined CVSS score, or -1.0 if none is found.
     */
    private Double determineCvssScore(Vulnerability scannedVulnerability) {
        if (scannedVulnerability == null) {
            return -1.0;
        }

        Double score = extractCvssV4Score(scannedVulnerability);
        if (score >= 0) {
            return score;
        }

        score = extractCvssV3Score(scannedVulnerability);
        if (score >= 0) {
            return score;
        }

        score = extractCvssV2Score(scannedVulnerability);
        if (score >= 0) {
            return score;
        }

        return -1.0;
    }

    private Double extractCvssV4Score(Vulnerability scannedVulnerability) {
        CvssV4 cvssV4 = scannedVulnerability.getCvssV4();
        if (cvssV4 != null) {
			cvssV4.getCvssData();
			return cvssV4.getCvssData().getBaseScore();
		}
        return -1.0;
    }

    private Double extractCvssV3Score(Vulnerability scannedVulnerability) {
        CvssV3 cvssV3 = scannedVulnerability.getCvssV3();
        if (cvssV3 != null) {
			cvssV3.getCvssData();
			return cvssV3.getCvssData().getBaseScore();
		}
        return -1.0;
    }

    private Double extractCvssV2Score(Vulnerability scannedVulnerability) {
        CvssV2 cvssV2 = scannedVulnerability.getCvssV2();
        if (cvssV2 != null) {
			cvssV2.getCvssData();
			return cvssV2.getCvssData().getBaseScore();
		}
        return -1.0;
    }
}
