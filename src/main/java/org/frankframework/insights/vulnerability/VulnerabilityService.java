package org.frankframework.insights.vulnerability;

import io.github.jeremylong.openvulnerability.client.nvd.CvssV2;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV2Data;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3Data;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV4;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import io.github.jeremylong.openvulnerability.client.nvd.CvssV4Data;
import lombok.extern.slf4j.Slf4j;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.common.properties.NVDProperties;
import org.frankframework.insights.common.properties.OSSProperties;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;
import org.owasp.dependencycheck.exception.ExceptionCollection;
import org.owasp.dependencycheck.utils.Settings;
import org.springframework.stereotype.Service;

@Service
@Slf4j
public class VulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ReleaseVulnerabilityRepository releaseVulnerabilityRepository;
    private final ReleaseRepository releaseRepository;
    private final ReleaseArtifactService releaseArtifactService;
	private final Mapper mapper;
    private final String ossIndexUsername;
    private final String ossIndexToken;
    private final String nvdApiKey;
    private final int nvdApiDelay;
    private static final int MAX_CVSS_ENTRY_SIZE = 255;

    public VulnerabilityService(
            VulnerabilityRepository vulnerabilityRepository,
            ReleaseVulnerabilityRepository releaseVulnerabilityRepository,
            ReleaseRepository releaseRepository,
            ReleaseArtifactService releaseArtifactService,
			Mapper mapper,
            OSSProperties ossProperties,
            NVDProperties nvdProperties) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.releaseVulnerabilityRepository = releaseVulnerabilityRepository;
        this.releaseRepository = releaseRepository;
        this.releaseArtifactService = releaseArtifactService;
		this.mapper = mapper;
        this.ossIndexUsername = ossProperties.getUsername();
        this.ossIndexToken = ossProperties.getToken();
        this.nvdApiKey = nvdProperties.getKey();
        this.nvdApiDelay = nvdProperties.getDelay();
    }

    /**
     * Executes a vulnerability scan for all releases in the database.
     * Each release is scanned in its own transaction via scanDirectory().
     */
    public void executeVulnerabilityScanForAllReleases() {
        List<Release> allReleases = releaseRepository.findAll();
        log.info("Starting full source code vulnerability scan for {} releases.", allReleases.size());

        VulnerabilityScanDTO results = scanAllReleases(allReleases);

        log.info(
                "Vulnerability scan process completed: {} releases succeeded, {} failed.",
                results.successCount(),
                results.failCount());
    }

	/**
	 * Scans all provided releases, counting successes and failures.
	 * @param releases The list of releases to scan.
	 * @return A VulnerabilityScanDTO containing the counts of successful and failed scans.
	 */
    private VulnerabilityScanDTO scanAllReleases(List<Release> releases) {
        int successCount = 0;
        int failCount = 0;

        for (Release release : releases) {
            if (scanSingleRelease(release)) {
                successCount++;
            } else {
                failCount++;
            }
        }
        return new VulnerabilityScanDTO(successCount, failCount);
    }

	/**
	 * Scans a single release by preparing its artifacts and scanning the directory.
	 * @param release The release to scan.
	 * @return true if the scan was successful, false otherwise.
	 */
    private boolean scanSingleRelease(Release release) {
        try {
            Path releaseDir = releaseArtifactService.prepareReleaseArtifacts(release);
            scanDirectory(release, releaseDir);
            return true;
        } catch (VulnerabilityScanException | IOException e) {
            log.error("Failed to download or scan source for release {}: {}", release.getName(), e.getMessage(), e);
            return false;
        }
    }

    /**
     * Scans the specified project directory for vulnerabilities and updates the database.
     * @param release The release associated with the project directory.
     * @param projectDirectory The path to the project directory to scan.
     * @throws VulnerabilityScanException if the scan encounters a fatal error.
     */
    private void scanDirectory(Release release, Path projectDirectory) throws VulnerabilityScanException {
        if (!isValidProjectDirectory(projectDirectory, release)) {
            return;
        }

        log.info(
                "Starting OWASP vulnerability scan for release: {} using directory: {}",
                release.getName(),
                projectDirectory);

        Settings settings = createOwaspSettings();
        executeScanWithEngine(release, projectDirectory, settings);

        log.info("OWASP vulnerability scan completed for release: {}", release.getName());
    }

	/**
	 * Validates that the project directory exists and is a directory.
	 * @param projectDirectory The path to the project directory to validate.
	 * @param release The release associated with the project directory.
	 * @return true if the directory is valid, false otherwise.
	 */
    private boolean isValidProjectDirectory(Path projectDirectory, Release release) {
        if (projectDirectory == null || !Files.isDirectory(projectDirectory)) {
            log.warn("Project directory is invalid or not found for release {}, scan skipped.", release.getName());
            return false;
        }
        return true;
    }

	/**
	 * Executes the OWASP Dependency-Check scan using the provided settings and processes results.
	 * @param release The release associated with the scan.
	 * @param projectDirectory The path to the project directory to scan.
	 * @param settings The OWASP Dependency-Check settings to use.
	 * @throws VulnerabilityScanException if a fatal error occurs during the scan.
	 */
    private void executeScanWithEngine(Release release, Path projectDirectory, Settings settings)
            throws VulnerabilityScanException {
        try (Engine engine = new Engine(settings)) {
            performScan(engine, projectDirectory, release);
            processScanResults(engine, release);
        } catch (Exception e) {
            handleFatalScanError(release, e);
        }
    }

	/**
	 * Performs the actual scanning of the project directory using the OWASP Dependency-Check engine.
	 * @param engine The OWASP Dependency-Check engine instance.
	 * @param projectDirectory The path to the project directory to scan.
	 * @param release The release associated with the project directory.
	 */
    private void performScan(Engine engine, Path projectDirectory, Release release) {
        try {
            engine.scan(projectDirectory.toFile());
            engine.analyzeDependencies();
        } catch (ExceptionCollection e) {
            handleNonFatalErrors(release, e);
        }
    }

	/**
	 * Handles non-fatal errors during the OWASP scan by logging warnings and continuing processing.
	 * @param release The release being scanned when the errors occurred.
	 * @param e The ExceptionCollection containing non-fatal errors.
	 */
    private void handleNonFatalErrors(Release release, ExceptionCollection e) {
        log.warn(
                "OWASP scan for release {} completed with non-fatal errors. Processing successful findings.",
                release.getName());
        for (Throwable throwable : e.getExceptions()) {
            log.warn("Non-fatal analysis error details: {}", throwable.getMessage());
        }
    }

	/**
	 * Processes the scan results from the OWASP engine and updates the database with found vulnerabilities.
	 * @param engine The OWASP Dependency-Check engine containing scan results.
	 * @param release The release associated with the scan results.
	 */
    private void processScanResults(Engine engine, Release release) {
        int vulnerabilityCount = countVulnerabilities(engine.getDependencies());
        log.info("Found {} vulnerabilities for release {}", vulnerabilityCount, release.getName());
        updateVulnerabilitiesForRelease(release, engine.getDependencies());
    }

	/**
	 * Handles fatal errors during the OWASP scan by logging and throwing a VulnerabilityScanException.
	 * @param release The release being scanned when the error occurred.
	 * @param e The exception that was thrown.
	 * @throws VulnerabilityScanException indicating the scan failure.
	 */
    private void handleFatalScanError(Release release, Exception e) throws VulnerabilityScanException {
        log.error(
                "A fatal OWASP vulnerability scan error occurred for release {}: {}",
                release.getName(),
                e.getMessage(),
                e);
        throw new VulnerabilityScanException("OWASP scan failed for " + release.getName(), e);
    }

    /**
     * Creates and configures OWASP Dependency-Check settings.
     * @return The configured Settings object.
     */
    private Settings createOwaspSettings() {
        Settings settings = new Settings();
        settings.setBoolean(Settings.KEYS.AUTO_UPDATE, true);

        configureOssIndexAnalyzer(settings);
        configureBasicAnalyzers(settings);
        configureNvdApi(settings);

        return settings;
    }

	/**
	 * Configures the OSS Index analyzer settings, including credentials if available.
	 * @param settings The Settings object to configure.
	 */
    private void configureOssIndexAnalyzer(Settings settings) {
        settings.setBoolean(Settings.KEYS.ANALYZER_OSSINDEX_ENABLED, true);

        if (hasValidOssIndexCredentials()) {
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_USER, this.ossIndexUsername);
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD, this.ossIndexToken);
        } else {
            log.warn(
                    "Sonatype OSS Index credentials are not configured. The OSS Index Analyzer will fail to initialize.");
        }
    }

	/**
	 * Checks if valid OSS Index credentials are configured.
	 * @return true if both username and token are non-null and non-blank, false otherwise.
	 */
    private boolean hasValidOssIndexCredentials() {
        return ossIndexUsername != null
                && !ossIndexUsername.isBlank()
                && ossIndexToken != null
                && !ossIndexToken.isBlank();
    }

	/**
	 * Configures basic analyzers for common file types like JARs and archives.
	 * @param settings The Settings object to configure.
	 */
    private void configureBasicAnalyzers(Settings settings) {
        settings.setBoolean(Settings.KEYS.ANALYZER_CENTRAL_ENABLED, false);
        settings.setBoolean(Settings.KEYS.ANALYZER_JAR_ENABLED, true);
        settings.setBoolean(Settings.KEYS.ANALYZER_ARCHIVE_ENABLED, true);
    }

	/**
	 * Configures the NVD API settings, including API key and request delay.
	 * @param settings The Settings object to configure.
	 */
    private void configureNvdApi(Settings settings) {
        if (nvdApiKey != null && !nvdApiKey.isEmpty()) {
            settings.setString(Settings.KEYS.NVD_API_KEY, this.nvdApiKey);
            settings.setInt(Settings.KEYS.NVD_API_DELAY, this.nvdApiDelay);
        } else {
            log.warn("No NVD API key configured. Scanning will be rate-limited and slower.");
        }
    }

    /**
     * Counts the total number of vulnerabilities across all dependencies.
     * @param dependencies The array of dependencies to count vulnerabilities from.
     * @return The total count of vulnerabilities.
     */
    private int countVulnerabilities(Dependency[] dependencies) {
        if (dependencies == null) return 0;
        int count = 0;
        for (Dependency dep : dependencies) {
            count += dep.getVulnerabilities().size();
        }
        return count;
    }

    /**
     * Updates the vulnerabilities associated with a release based on the scanned dependencies.
     * @param release The release to update vulnerabilities for.
     * @param scannedDependencies The dependencies scanned by OWASP containing vulnerability information.
     */
    private void updateVulnerabilitiesForRelease(Release release, Dependency[] scannedDependencies) {
        releaseVulnerabilityRepository.deleteAllByRelease(release);

        if (scannedDependencies == null) {
            return;
        }

        int savedCount = processAllVulnerabilities(release, scannedDependencies);
        log.info("Successfully linked {} vulnerabilities for release {}", savedCount, release.getName());
    }

	/**
	 * Processes all vulnerabilities from the scanned dependencies and links them to the release.
	 * @param release The release to link vulnerabilities to.
	 * @param scannedDependencies The dependencies containing vulnerabilities from the OWASP scan.
	 * @return The count of successfully linked vulnerabilities.
	 */
    private int processAllVulnerabilities(Release release, Dependency[] scannedDependencies) {
        int savedCount = 0;
        for (Dependency scannedDependency : scannedDependencies) {
            savedCount += processVulnerabilitiesForDependency(release, scannedDependency);
        }
        return savedCount;
    }

	/**
	 * Processes vulnerabilities for a single dependency and links them to the release.
	 * @param release The release to link vulnerabilities to.
	 * @param scannedDependency The dependency containing vulnerabilities from the OWASP scan.
	 * @return The count of successfully linked vulnerabilities.
	 */
    private int processVulnerabilitiesForDependency(Release release, Dependency scannedDependency) {
        int savedCount = 0;
        for (Vulnerability scannedVulnerability : scannedDependency.getVulnerabilities()) {
            if (linkVulnerabilityToRelease(release, scannedVulnerability)) {
                savedCount++;
            }
        }
        return savedCount;
    }

	/**
	 * Links a scanned vulnerability to a release, creating the vulnerability entity if it doesn't exist.
	 * @param release The release to link the vulnerability to.
	 * @param scannedVulnerability The vulnerability from the OWASP scan.
	 * @return true if the link was successfully created, false otherwise.
	 */
    private boolean linkVulnerabilityToRelease(Release release, Vulnerability scannedVulnerability) {
        try {
            org.frankframework.insights.vulnerability.Vulnerability vulnerability =
                    getOrCreateVulnerability(scannedVulnerability);
            ReleaseVulnerability link = new ReleaseVulnerability(release, vulnerability);
            releaseVulnerabilityRepository.save(link);
            return true;
        } catch (Exception e) {
            log.error(
                    "Failed to save or link vulnerability {} for release {}: {}",
                    scannedVulnerability.getName(),
                    release.getName(),
                    e.getMessage());
            return false;
        }
    }

	/**
	 * Fetches an existing Vulnerability entity by CVE ID or creates a new one if it doesn't exist.
	 * Always updates the entity with the latest scan data to ensure CVE information stays current.
	 * @param scannedVulnerability The vulnerability from the OWASP scan.
	 * @return The updated or newly created Vulnerability entity.
	 */
    private org.frankframework.insights.vulnerability.Vulnerability getOrCreateVulnerability(
            Vulnerability scannedVulnerability) {
        org.frankframework.insights.vulnerability.Vulnerability vulnerability =
                vulnerabilityRepository
                        .findById(scannedVulnerability.getName())
                        .orElse(new org.frankframework.insights.vulnerability.Vulnerability());

        // Always update with latest scan data (CVE scores and details can change over time)
        populateVulnerabilityScore(vulnerability, scannedVulnerability);
        populateVulnerabilityBasicInfo(vulnerability, scannedVulnerability);
        populateCweEntries(vulnerability, scannedVulnerability);

        return vulnerabilityRepository.save(vulnerability);
    }


	/**
	 * Populates the CVSS score and severity for a vulnerability.
	 * Always ensures a valid score is assigned, using representative scores when actual CVSS is unavailable.
	 * @param newVulnerability The Vulnerability entity to populate.
	 * @param scannedVulnerability The vulnerability from the OWASP scan.
	 */
    private void populateVulnerabilityScore(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        String cveId = scannedVulnerability.getName();
        Double cvssScore = determineCvssScore(scannedVulnerability);

        if (cvssScore != null && cvssScore >= 0.0) {
            // Use actual CVSS score
            newVulnerability.setCvssScore(cvssScore);
            VulnerabilitySeverity severity = VulnerabilitySeverity.fromScore(cvssScore);
            newVulnerability.setSeverity(severity);
            log.debug("CVE {}: Set severity {} from CVSS score {}", cveId, severity, cvssScore);
        } else {
            // No CVSS score available, derive from unscored severity string
            String unscoredSeverity = scannedVulnerability.getUnscoredSeverity();
            VulnerabilitySeverity severity = mapSeverityFromString(unscoredSeverity);
            newVulnerability.setSeverity(severity);

            // Use representative score based on severity
            double representativeScore = severity.getRepresentativeScore();
            newVulnerability.setCvssScore(representativeScore);

            if (severity == VulnerabilitySeverity.UNKNOWN) {
                log.warn("CVE {}: No valid CVSS score found and unscored severity '{}' resulted in UNKNOWN severity (using score {})",
                        cveId, unscoredSeverity, representativeScore);
                logDetailedVulnerabilityInfo(scannedVulnerability);
            } else {
                log.info("CVE {}: Set severity {} from unscored severity string '{}' (using representative score {})",
                        cveId, severity, unscoredSeverity, representativeScore);
            }
        }
    }

	/**
	 * Populates the basic information (CVE ID and description) for a vulnerability.
	 * @param newVulnerability The Vulnerability entity to populate.
	 * @param scannedVulnerability The vulnerability from the OWASP scan.
	 */
    private void populateVulnerabilityBasicInfo(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        newVulnerability.setCveId(scannedVulnerability.getName());
        newVulnerability.setDescription(scannedVulnerability.getDescription());
    }

	/**
	 * Populates the CWE entries for a vulnerability, limiting to a maximum number to avoid database issues.
	 * @param newVulnerability The Vulnerability entity to populate.
	 * @param scannedVulnerability The vulnerability from the OWASP scan.
	 */
    private void populateCweEntries(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        if (scannedVulnerability.getCwes() != null) {
            Set<String> cweEntries = scannedVulnerability.getCwes().getEntries().stream()
                    .limit(MAX_CVSS_ENTRY_SIZE)
                    .collect(Collectors.toSet());
            newVulnerability.setCwes(cweEntries);
        }
    }

    /**
     * Maps a severity string to the corresponding VulnerabilitySeverity enum.
     * @param severity The severity string to map.
     * @return The corresponding VulnerabilitySeverity, or UNKNOWN if not recognized.
     */
    private VulnerabilitySeverity mapSeverityFromString(String severity) {
        if (severity == null || severity.isBlank()) {
            log.debug("Severity string is null or blank, returning UNKNOWN");
            return VulnerabilitySeverity.UNKNOWN;
        }

        try {
            for (VulnerabilitySeverity s : VulnerabilitySeverity.values()) {
                if (s.name().equalsIgnoreCase(severity)) {
                    return s;
                }
            }
            log.warn("Unrecognized vulnerability severity string '{}', defaulting to UNKNOWN. " +
                    "Expected one of: CRITICAL, HIGH, MEDIUM, LOW, NONE, UNKNOWN", severity);
        } catch (Exception e) {
            log.error("Error while mapping vulnerability severity string '{}': {}", severity, e.getMessage(), e);
        }
        return VulnerabilitySeverity.UNKNOWN;
    }

    /**
     * Determines the most relevant CVSS score from a vulnerability, preferring v4.0, then v3.1, then v2.
     * This method is forward-compatible with future library updates that include CVSSv4.
     *
     * @param scannedVulnerability The vulnerability from the OWASP scan.
     * @return The determined CVSS score, or null if none is found.
     */
    private Double determineCvssScore(Vulnerability scannedVulnerability) {
        if (scannedVulnerability == null) {
            log.warn("Scanned vulnerability is null, cannot determine CVSS score");
            return null;
        }

        String cveId = scannedVulnerability.getName();
        log.debug("CVE {}: Determining CVSS score (trying v4 -> v3 -> v2)", cveId);

        Double score = extractCvssV4Score(scannedVulnerability);
        if (score != null && score >= 0) {
            log.info("CVE {}: Using CVSS v4 score: {}", cveId, score);
            return score;
        }

        score = extractCvssV3Score(scannedVulnerability);
        if (score != null && score >= 0) {
            log.info("CVE {}: Using CVSS v3 score: {}", cveId, score);
            return score;
        }

        score = extractCvssV2Score(scannedVulnerability);
        if (score != null && score >= 0) {
            log.info("CVE {}: Using CVSS v2 score: {}", cveId, score);
            return score;
        }

        log.warn("CVE {}: No valid CVSS score found in any version (v4, v3, v2)", cveId);
        return null;
    }

    private Double extractCvssV4Score(Vulnerability scannedVulnerability) {
        String cveId = scannedVulnerability.getName();
        CvssV4 cvssV4 = scannedVulnerability.getCvssV4();

        if (cvssV4 == null) {
            log.debug("CVE {}: No CVSS v4 data available (getCvssV4() returned null)", cveId);
            return null;
        }

        try {
            log.debug("CVE {}: CVSS v4 object found: {}", cveId, cvssV4);
            CvssV4Data cvssData = cvssV4.getCvssData();

			log.debug("CVE {}: CVSS v4 data found: {}", cveId, cvssData);
            Double baseScore = cvssData.getBaseScore();
            log.debug("CVE {}: CVSS v4 getBaseScore() returned: {}", cveId, baseScore);

			if (baseScore < 0) {
                log.warn("CVE {}: CVSS v4 returned invalid negative score: {}", cveId, baseScore);
                return null;
            }

            return baseScore;
        } catch (Exception e) {
            log.error("CVE {}: Error extracting CVSS v4 score: {}", cveId, e.getMessage(), e);
            return null;
        }
    }

    private Double extractCvssV3Score(Vulnerability scannedVulnerability) {
        String cveId = scannedVulnerability.getName();
        CvssV3 cvssV3 = scannedVulnerability.getCvssV3();

        if (cvssV3 == null) {
            log.debug("CVE {}: No CVSS v3 data available (getCvssV3() returned null)", cveId);
            return null;
        }

        try {
            log.debug("CVE {}: CVSS v3 object found: {}", cveId, cvssV3);
            CvssV3Data cvssData = cvssV3.getCvssData();

			log.debug("CVE {}: CVSS v3 data found: {}", cveId, cvssData);
            Double baseScore = cvssData.getBaseScore();
            log.debug("CVE {}: CVSS v3 getBaseScore() returned: {}", cveId, baseScore);

			if (baseScore < 0) {
                log.warn("CVE {}: CVSS v3 returned invalid negative score: {}", cveId, baseScore);
                return null;
            }

            return baseScore;
        } catch (Exception e) {
            log.error("CVE {}: Error extracting CVSS v3 score: {}", cveId, e.getMessage(), e);
            return null;
        }
    }

    private Double extractCvssV2Score(Vulnerability scannedVulnerability) {
        String cveId = scannedVulnerability.getName();
        CvssV2 cvssV2 = scannedVulnerability.getCvssV2();

        if (cvssV2 == null) {
            log.debug("CVE {}: No CVSS v2 data available (getCvssV2() returned null)", cveId);
            return null;
        }

        try {
            log.debug("CVE {}: CVSS v2 object found: {}", cveId, cvssV2);
			CvssV2Data cvssData = cvssV2.getCvssData();

			log.debug("CVE {}: CVSS v2 data found: {}", cveId, cvssData);
            Double baseScore = cvssData.getBaseScore();
            log.debug("CVE {}: CVSS v2 getBaseScore() returned: {}", cveId, baseScore);

			if (baseScore < 0) {
                log.warn("CVE {}: CVSS v2 returned invalid negative score: {}", cveId, baseScore);
                return null;
            }

            return baseScore;
        } catch (Exception e) {
            log.error("CVE {}: Error extracting CVSS v2 score: {}", cveId, e.getMessage(), e);
            return null;
        }
    }

    /**
     * Logs detailed information about a vulnerability when it ends up with UNKNOWN severity.
     * This helps debug why certain vulnerabilities have no usable score information.
     */
    private void logDetailedVulnerabilityInfo(Vulnerability scannedVulnerability) {
        String cveId = scannedVulnerability.getName();
        log.debug("CVE {}: Detailed vulnerability information dump", cveId);

        try {
            log.debug("CVE {}: getUnscoredSeverity() = '{}'", cveId, scannedVulnerability.getUnscoredSeverity());
            log.debug("CVE {}: getSource() = '{}'", cveId, scannedVulnerability.getSource());

            if (scannedVulnerability.getReferences() != null && !scannedVulnerability.getReferences().isEmpty()) {
                log.debug("CVE {}: Has {} reference(s)", cveId, scannedVulnerability.getReferences().size());
            } else {
                log.debug("CVE {}: No references available", cveId);
            }

            log.debug("CVE {}: getCvssV4() = {}", cveId, scannedVulnerability.getCvssV4());
            log.debug("CVE {}: getCvssV3() = {}", cveId, scannedVulnerability.getCvssV3());
            log.debug("CVE {}: getCvssV2() = {}", cveId, scannedVulnerability.getCvssV2());

            if (scannedVulnerability.getVulnerableSoftware() != null && !scannedVulnerability.getVulnerableSoftware().isEmpty()) {
                log.debug("CVE {}: Has {} vulnerable software entries", cveId, scannedVulnerability.getVulnerableSoftware().size());
            }

            log.debug("CVE {}: End of detailed information", cveId);
        } catch (Exception e) {
            log.error("CVE {}: Error while dumping detailed vulnerability info: {}", cveId, e.getMessage());
        }
    }

	/**
	 * Retrieves all vulnerabilities associated with a specific release.
	 * @param releaseId The ID of the release to fetch vulnerabilities for
	 * @return Set of vulnerability responses for the given release
	 */
	public Set<VulnerabilityResponse> getVulnerabilitiesByReleaseId(String releaseId) {
		if (releaseId == null || releaseId.isBlank()) {
			log.warn("Attempted to fetch vulnerabilities with null or blank release ID");
			return Set.of();
		}

		List<ReleaseVulnerability> releaseVulnerabilities = releaseVulnerabilityRepository.findAllByReleaseId(releaseId);

		if (releaseVulnerabilities.isEmpty()) {
			log.info("No vulnerabilities found for release ID: {}", releaseId);
			return Set.of();
		}

		Set<VulnerabilityResponse> responses = releaseVulnerabilities.stream()
				.map(ReleaseVulnerability::getVulnerability)
				.map(vulnerability -> mapper.toDTO(vulnerability, VulnerabilityResponse.class))
				.collect(Collectors.toSet());

		log.info("Found {} vulnerabilities for release ID: {}", responses.size(), releaseId);
		return responses;
	}
}
