package org.frankframework.insights.vulnerability;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.*;
import java.time.OffsetDateTime;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import lombok.extern.slf4j.Slf4j;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.frankframework.insights.release.releasecleanup.FileTreeDeleter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Slf4j
public class VulnerabilityService {
    private static final int TRIVY_TIMEOUT_MINUTES = 60;
    private static final long MAX_UNCOMPRESSED_SIZE = 2L * 1024 * 1024 * 1024;
    private static final int MAX_ENTRIES = 50_000;
    private static final int MAX_DATABASE_UPDATE_TIME = 30;
    private static final int BUFFER_SIZE = 8192;
    private static final Set<String> SKIP_EXTENSIONS = Set.of(
            ".java",
            ".cpp",
            ".c",
            ".h",
            ".py",
            ".go",
            ".ts",
            ".js",
            ".sh",
            ".bat",
            ".tiff",
            ".tif",
            ".bmp",
            ".jpg",
            ".jpeg",
            ".png",
            ".gif",
            ".svg",
            ".ico",
            ".webp",
            ".pdf",
            ".doc",
            ".docx",
            ".xls",
            ".xlsx",
            ".ppt",
            ".pptx",
            ".txt",
            ".md",
            ".rtf",
            ".msg",
            ".eml",
            ".csv",
            ".xsd",
            ".wsdl",
            ".properties",
            ".sql",
            ".conf",
            ".policy",
            ".editorconfig",
            ".gitignore",
            ".dockerignore",
            ".css",
            ".scss",
            ".less",
            ".sass",
            ".html",
            ".htm",
            ".xhtml",
            ".jks",
            ".p12",
            ".pfx",
            ".cer",
            ".crt",
            ".key",
            ".pem",
            ".asc",
            ".zip",
            ".tar",
            ".gz",
            ".7z",
            ".rar",
            ".woff",
            ".woff2",
            ".eot",
            ".ttf",
            ".otf");

    private static final List<String> SKIP_FOLDERS = List.of(
            "/src/test/",
            "/test/",
            "/tests/",
            "/testing/",
            "/doc/",
            "/docs/",
            "/javadoc/",
            "/documentation/",
            "/site/",
            "/apidocs/",
            "/samples/",
            "/examples/",
            "/demo/",
            "/demos/",
            "/mock/",
            "/mocks/",
            ".idea/",
            ".vscode/",
            ".git/",
            ".mvn/",
            "node_modules/",
            "/assets/");

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ReleaseVulnerabilityRepository releaseVulnerabilityRepository;
    private final ReleaseRepository releaseRepository;
    private final ReleaseArtifactService releaseArtifactService;
    private final Mapper mapper;
    private final FileTreeDeleter fileTreeDeleter;

    private final String trivyExecutable;
    private final String scanWorkspace;
    private final String trivyCacheDir;

    public VulnerabilityService(
            VulnerabilityRepository vulnerabilityRepository,
            ReleaseVulnerabilityRepository releaseVulnerabilityRepository,
            ReleaseRepository releaseRepository,
            ReleaseArtifactService releaseArtifactService,
            Mapper mapper,
            @Value("${trivy.path:trivy}") String trivyExecutable,
            @Value("${trivy.scan.workspace:/tmp/trivy-scan}") String scanWorkspace,
            @Value("${trivy.db.cache:/tmp/trivy-cache}") String trivyCacheDir) {

        this.vulnerabilityRepository = vulnerabilityRepository;
        this.releaseVulnerabilityRepository = releaseVulnerabilityRepository;
        this.releaseRepository = releaseRepository;
        this.releaseArtifactService = releaseArtifactService;
        this.mapper = mapper;

        this.trivyExecutable = trivyExecutable;
        this.scanWorkspace = scanWorkspace;
        this.trivyCacheDir = trivyCacheDir;

        this.fileTreeDeleter = new FileTreeDeleter();
    }

    public synchronized void scanAndSaveVulnerabilitiesForAllReleases() {
        List<Release> releases = releaseRepository.findAll();

        if (releases.isEmpty()) {
            log.info("No releases found to scan.");
            return;
        }

        List<Release> sortedReleases = releases.stream()
                .sorted(Comparator.comparing(Release::getLastScanned, Comparator.nullsFirst(Comparator.naturalOrder())))
                .toList();

        updateTrivyDatabases();

        for (Release release : sortedReleases) {
            try {
                processSingleRelease(release);
            } catch (Exception e) {
                log.error("Erro while scanning release {}", release.getTagName(), e);
            } finally {
                cleanupWorkspace();
            }
        }
    }

    private void updateTrivyDatabases() {
        log.info("Started updating Trivy databases in: {}", trivyCacheDir);
        runTrivyDbUpdate("Vulnerability DB", "--download-db-only");
        runTrivyDbUpdate("Java Index DB", "--download-java-db-only");
    }

    private void runTrivyDbUpdate(String dbName, String flag) {
        try {
            ProcessBuilder pb = new ProcessBuilder(trivyExecutable, "image", flag, "--cache-dir", trivyCacheDir);
            pb.inheritIO();
            Process p = pb.start();
            boolean finished = p.waitFor(MAX_DATABASE_UPDATE_TIME, TimeUnit.MINUTES);

            if (!finished || p.exitValue() != 0) {
                if (!finished) p.destroyForcibly();
                log.warn("{} update failed. We are trying to continue with cache.", dbName);
            } else {
                log.info("{} succesfully updated.", dbName);
            }
        } catch (Exception e) {
            log.warn("Error while updating {}: {}", dbName, e.getMessage());
        }
    }

    private void processSingleRelease(Release release) throws IOException, InterruptedException {
        log.info("Start verwerking release: {}", release.getTagName());

        Path zipOnPvc = releaseArtifactService.downloadReleaseZipToPvc(release.getTagName());

        Files.createDirectories(Paths.get(scanWorkspace));
        Path localZip = Paths.get(scanWorkspace, release.getTagName() + ".zip");
        Files.copy(zipOnPvc, localZip, StandardCopyOption.REPLACE_EXISTING);

        Path extractDir = Paths.get(scanWorkspace, "extracted-" + release.getTagName());

        unzipAndFilter(localZip, extractDir);

        TrivyReport report = executeTrivyScan(extractDir);

        List<TrivyVulnerability> vulns = parseVulnerabilitiesFromReport(report);
        persistScanResults(release, vulns);

        release.setLastScanned(OffsetDateTime.now());
        releaseRepository.save(release);
        log.info("Scan completed and saved for release {}", release.getTagName());
    }

    private TrivyReport executeTrivyScan(Path directoryToScan) throws IOException, InterruptedException {
        ProcessBuilder pb = new ProcessBuilder(
                trivyExecutable,
                "fs",
                "--format",
                "json",
                "--quiet",
                "--scanners",
                "vuln",
                "--vuln-type",
                "library",
                "--skip-db-update",
                "--skip-java-db-update",
                "--cache-dir",
                this.trivyCacheDir,
                "--timeout",
                TRIVY_TIMEOUT_MINUTES + "m",
                directoryToScan.toString());

        pb.environment().put("GOMAXPROCS", "1");
        pb.environment().put("TRIVY_OFFLINE_SCAN", "false");

        Process process = pb.start();
        String jsonOutput = readProcessOutput(process);

        boolean finished = process.waitFor(TRIVY_TIMEOUT_MINUTES, TimeUnit.MINUTES);
        if (!finished) {
            process.destroyForcibly();
            throw new IOException("Trivy scan time-out for " + directoryToScan);
        }

        if (process.exitValue() != 0) {
            log.error("Trivy error (Exit {}):", process.exitValue());
            throw new IOException("Trivy scan failed");
        }

        return parseTrivyOutput(jsonOutput);
    }

    /**
     * Unzips a ZIP file to the specified destination directory while filtering out unwanted files and folders.
     * Files with certain extensions and those located in specific folders are skipped.
     *
     * @param zipFile the path to the ZIP file
     * @param destDir the destination directory for extraction
     * @throws IOException if an I/O error occurs during extraction
     */
    private void unzipAndFilter(Path zipFile, Path destDir) throws IOException {
        Path normalizedDestDir = destDir.toAbsolutePath().normalize();
        Files.createDirectories(normalizedDestDir);

        try (ZipFile zf = new ZipFile(zipFile.toFile())) {
            Enumeration<? extends ZipEntry> entries = zf.entries();
            long[] totalSize = {0};
            int count = 0;

            while (entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                String entryName = entry.getName();

                if (shouldSkipExtension(entryName)) continue;
                if (shouldSkipFolder(entryName)) continue;

                Path destPath = normalizedDestDir.resolve(entryName).normalize();

                if (!destPath.startsWith(normalizedDestDir)) {
                    log.warn("Skipping potentially malicious zip entry: {}", entryName);
                    continue;
                }

                if (entry.isDirectory()) {
                    Files.createDirectories(destPath);
                    continue;
                }

                if (count++ > MAX_ENTRIES) {
                    throw new IOException("Too many files in archive (max: " + MAX_ENTRIES + ")");
                }

                Files.createDirectories(destPath.getParent());
                extractEntryWithSizeLimit(zf, entry, destPath, totalSize);
            }
        }
    }

    /**
     * Extracts a ZipEntry while enforcing a maximum uncompressed size limit.
     * This method reads the entry's data and writes it to the destination path,
     *
     * @param zf the ZipFile
     * @param entry the ZipEntry to extract
     * @param destPath the destination path for the extracted file
     * @param totalSize an array holding the cumulative uncompressed size
     * @throws IOException if an I/O error occurs or size limit is exceeded
     */
    private void extractEntryWithSizeLimit(ZipFile zf, ZipEntry entry, Path destPath, long[] totalSize)
            throws IOException {
        try (var inputStream = zf.getInputStream(entry);
                var outputStream = Files.newOutputStream(destPath)) {
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                totalSize[0] += bytesRead;
                if (totalSize[0] > MAX_UNCOMPRESSED_SIZE) {
                    throw new IOException("Uncompressed archive size exceeds limit");
                }
                outputStream.write(buffer, 0, bytesRead);
            }
        }
    }

    private boolean shouldSkipExtension(String fileName) {
        int dotIndex = fileName.lastIndexOf('.');
        if (dotIndex > 0) {
            String ext = fileName.substring(dotIndex).toLowerCase();
            return SKIP_EXTENSIONS.contains(ext);
        }
        return false;
    }

    private boolean shouldSkipFolder(String fileName) {
        String normalized = fileName.replace('\\', '/');
        for (String folder : SKIP_FOLDERS) {
            if (normalized.contains(folder)) return true;
        }
        return false;
    }

    private void cleanupWorkspace() {
        try {
            fileTreeDeleter.deleteTreeRecursively(Paths.get(scanWorkspace));
        } catch (Exception e) {
            log.error("Cleanup failed: {}", e.getMessage());
        }
    }

    private void persistScanResults(Release release, List<TrivyVulnerability> trivyVulnerabilities) {
        if (trivyVulnerabilities.isEmpty()) {
            handleEmptyScanResult(release);
            return;
        }
        log.info("Trivy scan for {} found {} vulnerabilities.", release.getTagName(), trivyVulnerabilities.size());
        Set<Vulnerability> savedVulnerabilities = getOrCreateVulnerabilities(trivyVulnerabilities);
        updateReleaseVulnerabilityLinks(release, savedVulnerabilities);
    }

    private void handleEmptyScanResult(Release release) {
        log.info("No vulnerabilities found for {}.", release.getTagName());
        releaseVulnerabilityRepository.deleteAllByReleaseId(release.getId());
    }

    private Set<Vulnerability> getOrCreateVulnerabilities(List<TrivyVulnerability> trivyVulnerabilities) {
        Set<String> cveIdsInReport = getCveIdsFromReport(trivyVulnerabilities);
        Map<String, Vulnerability> existingVulnsMap = fetchExistingVulnerabilities(cveIdsInReport);
        Set<Vulnerability> vulnerabilitiesToSave = mapVulnerabilitiesToEntities(trivyVulnerabilities, existingVulnsMap);
        return saveVulnerabilityBatch(vulnerabilitiesToSave);
    }

    private Set<String> getCveIdsFromReport(List<TrivyVulnerability> trivyVulnerabilities) {
        return trivyVulnerabilities.stream()
                .map(TrivyVulnerability::VulnerabilityID)
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }

    private Map<String, Vulnerability> fetchExistingVulnerabilities(Set<String> cveIds) {
        return vulnerabilityRepository.findAllById(cveIds).stream()
                .collect(Collectors.toMap(Vulnerability::getCveId, v -> v));
    }

    private Set<Vulnerability> mapVulnerabilitiesToEntities(
            List<TrivyVulnerability> trivyVulnerabilities, Map<String, Vulnerability> existingVulnsMap) {
        return trivyVulnerabilities.stream()
                .map(tv -> mapTrivyVulnerabilityToEntity(tv, existingVulnsMap))
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
    }

    private Set<Vulnerability> saveVulnerabilityBatch(Set<Vulnerability> vulnerabilitiesToSave) {
        List<Vulnerability> savedVulnerabilities = vulnerabilityRepository.saveAll(vulnerabilitiesToSave);
        return new HashSet<>(savedVulnerabilities);
    }

    private void updateReleaseVulnerabilityLinks(Release release, Set<Vulnerability> vulnerabilities) {
        releaseVulnerabilityRepository.deleteAllByReleaseId(release.getId());
        if (vulnerabilities.isEmpty()) return;

        List<ReleaseVulnerability> newLinks = vulnerabilities.stream()
                .map(v -> {
                    ReleaseVulnerability link = new ReleaseVulnerability();
                    link.setRelease(release);
                    link.setVulnerability(v);
                    return link;
                })
                .toList();
        releaseVulnerabilityRepository.saveAll(newLinks);
    }

    private Vulnerability mapTrivyVulnerabilityToEntity(
            TrivyVulnerability trivyVulnerability, Map<String, Vulnerability> existingVulnerabilitiesMap) {
        if (trivyVulnerability == null || trivyVulnerability.VulnerabilityID() == null) return null;

        String cveId = trivyVulnerability.VulnerabilityID();
        Vulnerability vulnerability = existingVulnerabilitiesMap.computeIfAbsent(cveId, id -> {
            Vulnerability v = new Vulnerability();
            v.setCveId(id);
            return v;
        });

        vulnerability.setDescription(trivyVulnerability.buildDescription());
        vulnerability.setCwes(trivyVulnerability.getCweIdsAsSet());
        VulnerabilitySeverity severity = trivyVulnerability.toVulnerabilitySeverity();
        vulnerability.setSeverity(severity);
        vulnerability.setCvssScore(getEffectiveCvssScore(trivyVulnerability, severity, vulnerability.getCvssScore()));

        return vulnerability;
    }

    private Double getEffectiveCvssScore(
            TrivyVulnerability trivyVulnerability, VulnerabilitySeverity severity, Double existingScore) {
        return trivyVulnerability
                .extractCvssScore()
                .or(() -> Optional.ofNullable(existingScore))
                .orElseGet(severity::getRepresentativeScore);
    }

    @Transactional(readOnly = true)
    public Set<VulnerabilityResponse> getAllVulnerabilities() {
        try {
            return vulnerabilityRepository.findAll().stream()
                    .map(v -> mapper.toDTO(v, VulnerabilityResponse.class))
                    .collect(Collectors.toSet());
        } catch (Exception e) {
            log.error("Error fetching all vulnerabilities", e);
            return Collections.emptySet();
        }
    }

    @Transactional(readOnly = true)
    public Set<VulnerabilityResponse> getVulnerabilitiesByReleaseId(String releaseId) {
        if (releaseId == null || releaseId.isBlank()) return Collections.emptySet();

        try {
            return releaseVulnerabilityRepository.findAllByReleaseId(releaseId).stream()
                    .map(ReleaseVulnerability::getVulnerability)
                    .filter(Objects::nonNull)
                    .map(v -> mapper.toDTO(v, VulnerabilityResponse.class))
                    .collect(Collectors.toSet());
        } catch (Exception e) {
            log.error("Error fetching vulnerabilities for release {}", releaseId, e);
            return Collections.emptySet();
        }
    }

    @Transactional
    public VulnerabilityResponse updateVulnerabilityImpact(String cveId, VulnerabilityImpactRequest request)
            throws VulnerabilityNotFoundException {
        if (request == null || request.impactScore() == null || request.impactDescription() == null) {
            throw new IllegalArgumentException("Request cannot be null");
        }

        Vulnerability vulnerability = vulnerabilityRepository
                .findById(cveId)
                .orElseThrow(() -> new VulnerabilityNotFoundException("Vulnerability not found: " + cveId));

        vulnerability.setImpactScore(request.impactScore());
        vulnerability.setImpactDescription(request.impactDescription());

        Vulnerability saved = vulnerabilityRepository.save(vulnerability);
        return mapper.toDTO(saved, VulnerabilityResponse.class);
    }

    @Transactional
    public void deleteVulnerabilityImpact(String cveId) throws VulnerabilityNotFoundException {
        Vulnerability vulnerability = vulnerabilityRepository
                .findById(cveId)
                .orElseThrow(() -> new VulnerabilityNotFoundException("Vulnerability not found: " + cveId));

        vulnerability.setImpactScore(null);
        vulnerability.setImpactDescription(null);
        vulnerabilityRepository.save(vulnerability);
    }

    private String readProcessOutput(Process process) throws IOException {
        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) output.append(line);
        }
        return output.toString();
    }

    private TrivyReport parseTrivyOutput(String jsonOutput) throws IOException {
        if (jsonOutput == null || jsonOutput.isBlank()) return new TrivyReport();
        try {
            return mapper.fromJson(jsonOutput, TrivyReport.class);
        } catch (Exception e) {
            throw new IOException("Failed to parse Trivy JSON output", e);
        }
    }

    private List<TrivyVulnerability> parseVulnerabilitiesFromReport(TrivyReport report) {
        if (report == null || report.Results == null) return Collections.emptyList();
        return report.Results.stream()
                .filter(r -> r.Vulnerabilities() != null)
                .flatMap(r -> r.Vulnerabilities().stream())
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
}
