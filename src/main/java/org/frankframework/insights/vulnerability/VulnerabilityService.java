package org.frankframework.insights.vulnerability;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.extern.slf4j.Slf4j;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.common.properties.NVDProperties;
import org.frankframework.insights.common.properties.OSSProperties;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;
import org.owasp.dependencycheck.exception.ExceptionCollection;
import org.owasp.dependencycheck.utils.Settings;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
@Slf4j
public class VulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ReleaseVulnerabilityRepository releaseVulnerabilityRepository;
    private final ReleaseRepository releaseRepository;
    private final ReleaseArtifactService releaseArtifactService;
    private final Mapper mapper;
    private final String ossIndexUsername;
    private final String ossIndexToken;
    private final String nvdApiKey;
    private final int nvdApiDelay;
    private static final int MAX_CVSS_ENTRY_SIZE = 255;
    private static final int NVD_API_RESULTS_PER_PAGE = 500;
    private final String owaspDataDirectory;

    public VulnerabilityService(
            VulnerabilityRepository vulnerabilityRepository,
            ReleaseVulnerabilityRepository releaseVulnerabilityRepository,
            ReleaseRepository releaseRepository,
            ReleaseArtifactService releaseArtifactService,
            Mapper mapper,
            OSSProperties ossProperties,
            NVDProperties nvdProperties,
            @Value("${owasp.data.directory:./.owasp-data}") String owaspDataDirectory) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.releaseVulnerabilityRepository = releaseVulnerabilityRepository;
        this.releaseRepository = releaseRepository;
        this.releaseArtifactService = releaseArtifactService;
        this.mapper = mapper;
        this.ossIndexUsername = ossProperties.getUsername();
        this.ossIndexToken = ossProperties.getToken();
        this.nvdApiKey = nvdProperties.getKey();
        this.nvdApiDelay = nvdProperties.getDelay();
        this.owaspDataDirectory = owaspDataDirectory;
    }

    /**
     * Executes a vulnerability scan for all releases in the system.
     */
    public void executeVulnerabilityScanForAllReleases() {
        cleanUpOwaspLockFile();

        List<Release> allReleases = releaseRepository.findAll();
        log.info("Starting full source code vulnerability scan for {} releases.", allReleases.size());

        VulnerabilityScanDTO results = scanAllReleases(allReleases);

        log.info(
                "Vulnerability scan process completed: {} releases succeeded, {} failed.",
                results.successCount(),
                results.failCount());
    }

    /**
     * Scans all provided releases and returns a summary of the results.
     * @param releases the list of releases to scan
     * @return a VulnerabilityScanDTO summarizing the scan results
     */
    private VulnerabilityScanDTO scanAllReleases(List<Release> releases) {
        int successCount = 0;
        int failCount = 0;
        for (Release release : releases) {
            if (scanSingleRelease(release)) {
                successCount++;
            } else {
                failCount++;
            }
        }
        return new VulnerabilityScanDTO(successCount, failCount);
    }

    /**
     * Scans a single release for vulnerabilities.
     * @param release the release to scan
     * @return true if the scan was successful, false otherwise
     */
    private boolean scanSingleRelease(Release release) {
        try {
            Path releaseDir = releaseArtifactService.prepareReleaseArtifacts(release);
            scanDirectory(release, releaseDir);
            return true;
        } catch (VulnerabilityScanException | IOException e) {
            String message = e.getMessage();
            if (message != null && message.contains("Database has been cleaned")) {
                log.error(
                        "Database corruption detected. The scan for release [{}] has been aborted.", release.getName());
                log.info("The OWASP database has been cleaned and will be rebuilt on the next scan.");
            } else {
                log.error("Failed to download or scan source for release {}: {}", release.getName(), e.getMessage(), e);
            }
            return false;
        }
    }

    /**
     * Scans the specified project directory for vulnerabilities using OWASP Dependency-Check.
     * @param release the release being scanned
     * @param projectDirectory the path to the project directory to scan
     * @throws VulnerabilityScanException if a fatal error occurs during the scan
     */
    private void scanDirectory(Release release, Path projectDirectory) throws VulnerabilityScanException {
        if (!isValidProjectDirectory(projectDirectory, release)) {
            return;
        }
        log.info(
                "Starting OWASP vulnerability scan for release: {} using directory: {}",
                release.getName(),
                projectDirectory);
        Settings settings = createOwaspSettings();
        executeScanWithEngine(release, projectDirectory, settings);
        log.info("OWASP vulnerability scan completed for release: {}", release.getName());
    }

    /**
     * Executes the vulnerability scan using the OWASP Dependency-Check engine.
     * @param release the release being scanned
     * @param projectDirectory the path to the project directory to scan
     * @param settings the OWASP Dependency-Check settings
     * @throws VulnerabilityScanException if a fatal error occurs during the scan
     */
    private void executeScanWithEngine(Release release, Path projectDirectory, Settings settings)
            throws VulnerabilityScanException {
        try (Engine engine = new Engine(settings)) {
            performScan(engine, projectDirectory, release);
            processScanResults(engine, release);
        } catch (VulnerabilityScanException e) {
            throw e;
        } catch (Exception e) {
            handleFatalScanError(release, e);
        }
    }

    /**
     * Performs the actual scanning and analysis using the OWASP Dependency-Check engine.
     * @param engine the OWASP Dependency-Check engine
     * @param projectDirectory the path to the project directory to scan
     * @param release the release being scanned
     * @throws VulnerabilityScanException if a non-fatal error related to database corruption occurs
     */
    private void performScan(Engine engine, Path projectDirectory, Release release) throws VulnerabilityScanException {
        try {
            engine.scan(projectDirectory.toFile());
            engine.analyzeDependencies();
        } catch (ExceptionCollection e) {
            if (handleNonFatalErrors(release, e)) {
                throw new VulnerabilityScanException("Scan failed for " + release.getName()
                        + " due to database corruption. Database has been cleaned for the next run.");
            }
        }
    }

    /**
     * Handles non-fatal errors that occur during the scan.
     * @param release the release being scanned
     * @param e the collection of non-fatal exceptions
     * @return true if database corruption was detected and handled, false otherwise
     */
    private boolean handleNonFatalErrors(Release release, ExceptionCollection e) {
        log.warn(
                "OWASP scan for release {} completed with non-fatal errors. Analyzing for root cause.",
                release.getName());
        boolean corruptionFound = false;
        for (Throwable throwable : e.getExceptions()) {
            log.warn("Non-fatal analysis error details: {}", throwable.getMessage());
            if (!corruptionFound && isH2DatabaseCorruption(new Exception(throwable))) {
                log.warn("H2 database corruption detected within non-fatal errors. Triggering cleanup.");
                cleanH2DatabaseFiles();
                corruptionFound = true;
            }
        }
        return corruptionFound;
    }

    /**
     * Processes the scan results and updates the vulnerabilities for the release.
     * @param engine the OWASP Dependency-Check engine
     * @param release the release being scanned
     */
    private void processScanResults(Engine engine, Release release) {
        int vulnerabilityCount = countVulnerabilities(engine.getDependencies());
        log.info("Found {} vulnerabilities for release {}", vulnerabilityCount, release.getName());
        updateVulnerabilitiesForRelease(release, engine.getDependencies());
    }

    /**
     * Handles fatal errors that occur during the scan.
     * @param release the release being scanned
     * @param e the exception that occurred
     * @throws VulnerabilityScanException indicating the scan failure
     */
    private void handleFatalScanError(Release release, Exception e) throws VulnerabilityScanException {
        log.error(
                "A fatal OWASP vulnerability scan error occurred for release {}: {}",
                release.getName(),
                e.getMessage(),
                e);
        throw new VulnerabilityScanException("OWASP scan failed for " + release.getName());
    }

    /**
     * Cleans up stale OWASP lock files in the data directory.
     */
    private void cleanUpOwaspLockFile() {
        try {
            Path dataDirectory = getOwaspDataDirectory();
            if (dataDirectory == null || !Files.isDirectory(dataDirectory)) return;
            try (Stream<Path> files = Files.list(dataDirectory)) {
                files.filter(this::isH2LockFile).forEach(this::deleteSafely);
            }
        } catch (Exception e) {
            log.error("Failed to clean up stale lock files", e);
        }
    }

    /**
     * Checks if the given path corresponds to an H2 database lock file.
     * @param path the path to check
     * @return true if the path is an H2 lock file, false otherwise
     */
    private boolean isH2LockFile(Path path) {
        String fileName = path.getFileName().toString();
        return fileName.endsWith(".lock") || fileName.endsWith(".lock.db") || fileName.endsWith(".mv.db.lock");
    }

    /**
     * Determines if the provided exception or any of its causes indicate H2 database corruption.
     * @param exception the exception to analyze
     * @return true if H2 database corruption is detected, false otherwise
     */
    private boolean isH2DatabaseCorruption(Exception exception) {
        Throwable current = exception;
        while (current != null) {
            String className = current.getClass().getName();
            String message = current.getMessage() != null ? current.getMessage().toLowerCase() : "";
            if (isH2ExceptionClass(className) || isH2CorruptionMessage(message)) {
                return true;
            }
            current = current.getCause();
        }
        return false;
    }

    /**
     * Checks if the exception class name indicates an H2 database exception.
     * @param className the exception class name
     * @return true if it is an H2 exception class, false otherwise
     */
    private boolean isH2ExceptionClass(String className) {
        return className.contains("JdbcSQL") || className.contains("DbException") || className.startsWith("org.h2.");
    }

    /**
     * Checks if the exception message indicates H2 database corruption.
     * @param message the exception message
     * @return true if it indicates corruption, false otherwise
     */
    private boolean isH2CorruptionMessage(String message) {
        return message.contains("database is corrupt")
                || message.contains("file corrupted")
                || message.contains("checksum mismatch")
                || message.contains("database may be already in use")
                || message.contains("connection is closed")
                || message.contains("timeout trying to lock")
                || message.contains("unable to connect");
    }

    /**
     * Cleans up H2 database files in the OWASP data directory.
     */
    private void cleanH2DatabaseFiles() {
        try {
            Path dataDirectory = getOwaspDataDirectory();
            if (dataDirectory == null || !Files.isDirectory(dataDirectory)) return;

            log.warn("Removing corrupt H2 database files from: {}", dataDirectory);
            long deletedCount;
            try (Stream<Path> files = Files.list(dataDirectory)) {
                deletedCount = files.filter(this::isH2DatabaseFile)
                        .filter(this::deleteSafely)
                        .count();
            }
            log.info("Successfully cleaned {} H2 database file(s).", deletedCount);
        } catch (Exception e) {
            log.error("A critical error occurred while trying to clean H2 database files.", e);
        }
    }

    /**
     * Deletes the specified file safely, logging the outcome.
     * @param file the file to delete
     * @return true if deletion was successful, false otherwise
     */
    private boolean deleteSafely(Path file) {
        try {
            Files.delete(file);
            log.warn("Removed H2 file: {}", file.getFileName());
            return true;
        } catch (IOException e) {
            log.error("Failed to delete file: {}", file, e);
            return false;
        }
    }

    /**
     * Resolves the OWASP data directory path from settings.
     * @return the path to the OWASP data directory, or null if resolution fails
     */
    private Path getOwaspDataDirectory() {
        try {
            Settings settings = new Settings();
            settings.setString(Settings.KEYS.DATA_DIRECTORY, owaspDataDirectory);
            return settings.getDataDirectory().toPath();
        } catch (IOException e) {
            log.error("Failed to resolve OWASP data directory: {}", owaspDataDirectory, e);
            return null;
        }
    }

    /**
     * Checks if the given path corresponds to an H2 database file.
     * @param path the path to check
     * @return true if the path is an H2 database file, false otherwise
     */
    private boolean isH2DatabaseFile(Path path) {
        if (Files.isDirectory(path)) return false;
        String fileName = path.getFileName().toString().toLowerCase();
        return fileName.endsWith(".mv.db") || fileName.endsWith(".trace.db") || fileName.endsWith(".lock.db");
    }

    /**
     * Validates the project directory before scanning.
     * @param projectDirectory the project directory path
     * @param release the release being scanned
     * @return true if the directory is valid, false otherwise
     */
    private boolean isValidProjectDirectory(Path projectDirectory, Release release) {
        if (projectDirectory == null || !Files.isDirectory(projectDirectory)) {
            log.warn("Project directory is invalid or not found for release {}, scan skipped.", release.getName());
            return false;
        }
        return true;
    }

    /**
     * Creates and configures OWASP Dependency-Check settings.
     * @return the configured Settings object
     */
    protected Settings createOwaspSettings() {
        Settings settings = new Settings();
        settings.setString(Settings.KEYS.DATA_DIRECTORY, owaspDataDirectory);
        settings.setBoolean(Settings.KEYS.AUTO_UPDATE, true);
        configureOssIndexAnalyzer(settings);
        configureBasicAnalyzers(settings);
        configureNvdApi(settings);
        return settings;
    }

    /**
     * Configures the Sonatype OSS Index analyzer settings.
     * @param settings the Settings object to configure
     */
    private void configureOssIndexAnalyzer(Settings settings) {
        settings.setBoolean(Settings.KEYS.ANALYZER_OSSINDEX_ENABLED, true);
        if (hasValidOssIndexCredentials()) {
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_USER, this.ossIndexUsername);
            settings.setString(Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD, this.ossIndexToken);
        } else {
            log.warn(
                    "Sonatype OSS Index credentials are not configured. The OSS Index Analyzer will fail to initialize.");
        }
    }

    /**
     * Checks if valid OSS Index credentials are provided.
     * @return true if both username and token are non-blank, false otherwise
     */
    private boolean hasValidOssIndexCredentials() {
        return ossIndexUsername != null
                && !ossIndexUsername.isBlank()
                && ossIndexToken != null
                && !ossIndexToken.isBlank();
    }

    /**
     * Configures basic analyzers in the OWASP Dependency-Check settings.
     * @param settings the Settings object to configure
     */
    private void configureBasicAnalyzers(Settings settings) {
        settings.setBoolean(Settings.KEYS.ANALYZER_CENTRAL_ENABLED, false);
        settings.setBoolean(Settings.KEYS.ANALYZER_JAR_ENABLED, true);
        settings.setBoolean(Settings.KEYS.ANALYZER_ARCHIVE_ENABLED, true);
    }

    /**
     * Configures the NVD API settings.
     * @param settings the Settings object to configure
     */
    private void configureNvdApi(Settings settings) {
        if (nvdApiKey != null && !nvdApiKey.isEmpty()) {
            settings.setString(Settings.KEYS.NVD_API_KEY, this.nvdApiKey);
            settings.setInt(Settings.KEYS.NVD_API_DELAY, this.nvdApiDelay);
            settings.setInt(Settings.KEYS.NVD_API_RESULTS_PER_PAGE, NVD_API_RESULTS_PER_PAGE);
        } else {
            log.warn("No NVD API key configured. Scanning will be rate-limited and slower.");
        }
    }

    /**
     * Counts the total number of vulnerabilities across all dependencies.
     * @param dependencies the array of dependencies to analyze
     * @return the total vulnerability count
     */
    protected int countVulnerabilities(Dependency[] dependencies) {
        if (dependencies == null) return 0;
        int count = 0;
        for (Dependency dep : dependencies) {
            count += dep.getVulnerabilities().size();
        }
        return count;
    }

    /**
     * Updates the vulnerabilities associated with a release based on scanned dependencies.
     * @param release the release to update
     * @param scannedDependencies the array of scanned dependencies
     */
    private void updateVulnerabilitiesForRelease(Release release, Dependency[] scannedDependencies) {
        releaseVulnerabilityRepository.deleteAllByRelease(release);
        if (scannedDependencies == null) return;
        int savedCount = processAllVulnerabilities(release, scannedDependencies);
        log.info("Successfully linked {} vulnerabilities for release {}", savedCount, release.getName());
    }

    /**
     * Processes all vulnerabilities from scanned dependencies and links them to the release.
     * @param release the release to link vulnerabilities to
     * @param scannedDependencies the array of scanned dependencies
     * @return the count of successfully linked vulnerabilities
     */
    private int processAllVulnerabilities(Release release, Dependency[] scannedDependencies) {
        int savedCount = 0;
        for (Dependency scannedDependency : scannedDependencies) {
            savedCount += processVulnerabilitiesForDependency(release, scannedDependency);
        }
        return savedCount;
    }

    /**
     * Processes vulnerabilities for a single dependency and links them to the release.
     * @param release the release to link vulnerabilities to
     * @param scannedDependency the scanned dependency
     * @return the count of successfully linked vulnerabilities
     */
    private int processVulnerabilitiesForDependency(Release release, Dependency scannedDependency) {
        int savedCount = 0;
        for (Vulnerability scannedVulnerability : scannedDependency.getVulnerabilities()) {
            if (linkVulnerabilityToRelease(release, scannedVulnerability)) {
                savedCount++;
            }
        }
        return savedCount;
    }

    /**
     * Links a scanned vulnerability to the specified release.
     * @param release the release to link the vulnerability to
     * @param scannedVulnerability the scanned vulnerability
     * @return true if linking was successful, false otherwise
     */
    private boolean linkVulnerabilityToRelease(Release release, Vulnerability scannedVulnerability) {
        try {
            org.frankframework.insights.vulnerability.Vulnerability vulnerability =
                    getOrCreateVulnerability(scannedVulnerability);
            ReleaseVulnerability link = new ReleaseVulnerability(release, vulnerability);
            releaseVulnerabilityRepository.save(link);
            return true;
        } catch (Exception e) {
            log.error(
                    "Failed to save or link vulnerability {} for release {}: {}",
                    scannedVulnerability.getName(),
                    release.getName(),
                    e.getMessage());
            return false;
        }
    }

    /**
     * Retrieves an existing vulnerability or creates a new one based on the scanned vulnerability data.
     * @param scannedVulnerability the scanned vulnerability
     * @return the existing or newly created Vulnerability entity
     */
    protected org.frankframework.insights.vulnerability.Vulnerability getOrCreateVulnerability(
            Vulnerability scannedVulnerability) {
        org.frankframework.insights.vulnerability.Vulnerability vulnerability = vulnerabilityRepository
                .findById(scannedVulnerability.getName())
                .orElse(new org.frankframework.insights.vulnerability.Vulnerability());

        populateVulnerabilityScore(vulnerability, scannedVulnerability);
        populateVulnerabilityBasicInfo(vulnerability, scannedVulnerability);
        populateCweEntries(vulnerability, scannedVulnerability);

        return vulnerabilityRepository.save(vulnerability);
    }

    /**
     * Populates the CVSS score and severity of the vulnerability.
     * @param newVulnerability the Vulnerability entity to populate
     * @param scannedVulnerability the scanned vulnerability data
     */
    private void populateVulnerabilityScore(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        Double cvssScore = determineCvssScore(scannedVulnerability);
        if (cvssScore != null && cvssScore >= 0.0) {
            newVulnerability.setCvssScore(cvssScore);
            newVulnerability.setSeverity(VulnerabilitySeverity.fromScore(cvssScore));
        } else {
            VulnerabilitySeverity severity = mapSeverityFromString(scannedVulnerability.getUnscoredSeverity());
            newVulnerability.setSeverity(severity);
            newVulnerability.setCvssScore(severity.getRepresentativeScore());
        }
    }

    /**
     * Populates basic information of the vulnerability.
     * @param newVulnerability the Vulnerability entity to populate
     * @param scannedVulnerability the scanned vulnerability data
     */
    private void populateVulnerabilityBasicInfo(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        newVulnerability.setCveId(scannedVulnerability.getName());
        newVulnerability.setDescription(scannedVulnerability.getDescription());
    }

    /**
     * Populates CWE entries of the vulnerability.
     * @param newVulnerability the Vulnerability entity to populate
     * @param scannedVulnerability the scanned vulnerability data
     */
    private void populateCweEntries(
            org.frankframework.insights.vulnerability.Vulnerability newVulnerability,
            Vulnerability scannedVulnerability) {
        if (scannedVulnerability.getCwes() != null) {
            Set<String> cweEntries = scannedVulnerability.getCwes().getEntries().stream()
                    .limit(MAX_CVSS_ENTRY_SIZE)
                    .collect(Collectors.toSet());
            newVulnerability.setCwes(cweEntries);
        }
    }

    /**
     * Maps a severity string to the VulnerabilitySeverity enum.
     * @param severity the severity string
     * @return the corresponding VulnerabilitySeverity enum value
     */
    protected VulnerabilitySeverity mapSeverityFromString(String severity) {
        if (severity == null || severity.isBlank()) {
            return VulnerabilitySeverity.UNKNOWN;
        }
        try {
            return VulnerabilitySeverity.valueOf(severity.toUpperCase());
        } catch (IllegalArgumentException e) {
            log.warn("Unrecognized vulnerability severity string '{}', defaulting to UNKNOWN.", severity);
            return VulnerabilitySeverity.UNKNOWN;
        }
    }

    /**
     * Determines the CVSS score from the scanned vulnerability, prioritizing v4, then v3, then v2.
     * @param scannedVulnerability the scanned vulnerability
     * @return the CVSS score, or null if none found
     */
    protected Double determineCvssScore(Vulnerability scannedVulnerability) {
        if (scannedVulnerability == null) return null;
        Double score = extractCvssV4Score(scannedVulnerability);
        if (score != null) return score;
        score = extractCvssV3Score(scannedVulnerability);
        if (score != null) return score;
        return extractCvssV2Score(scannedVulnerability);
    }

    /**
     * Extracts the CVSS v4 score from the vulnerability.
     * @param v the scanned vulnerability
     * @return the CVSS v4 score, or null if not available
     */
    private Double extractCvssV4Score(Vulnerability v) {
        return extractCvssScore(
                v, "v4", v.getCvssV4(), cvss -> cvss.getCvssData().getBaseScore());
    }

    /**
     * Extracts the CVSS v3 score from the vulnerability.
     * @param v the scanned vulnerability
     * @return the CVSS v3 score, or null if not available
     */
    private Double extractCvssV3Score(Vulnerability v) {
        return extractCvssScore(
                v, "v3", v.getCvssV3(), cvss -> cvss.getCvssData().getBaseScore());
    }

    /**
     * Extracts the CVSS v2 score from the vulnerability.
     * @param v the scanned vulnerability
     * @return the CVSS v2 score, or null if not available
     */
    private Double extractCvssV2Score(Vulnerability v) {
        return extractCvssScore(
                v, "v2", v.getCvssV2(), cvss -> cvss.getCvssData().getBaseScore());
    }

    /**
     * Generic method to extract CVSS score using the provided extractor function.
     * @param v the scanned vulnerability
     * @param version the CVSS version string
     * @param cvssObject the CVSS object to extract the score from
     * @param extractor the function to extract the score
     * @return the extracted CVSS score, or null if not available
     * @param <T> the type of the CVSS object
     */
    private <T> Double extractCvssScore(
            Vulnerability v, String version, T cvssObject, java.util.function.Function<T, Double> extractor) {
        if (cvssObject == null) return null;
        try {
            Double score = extractor.apply(cvssObject);
            if (score != null && score >= 0.0) {
                return score;
            }
        } catch (Exception e) {
            log.error("CVE {}: Error extracting CVSS {} score: {}", v.getName(), version, e.getMessage());
        }
        return null;
    }

    /**
     * Retrieves vulnerabilities associated with a specific release ID.
     * @param releaseId the release ID
     * @return set of VulnerabilityResponse DTOs
     */
    public Set<VulnerabilityResponse> getVulnerabilitiesByReleaseId(String releaseId) {
        if (releaseId == null || releaseId.isBlank()) {
            return Set.of();
        }
        return releaseVulnerabilityRepository.findAllByReleaseId(releaseId).stream()
                .map(ReleaseVulnerability::getVulnerability)
                .map(v -> mapper.toDTO(v, VulnerabilityResponse.class))
                .collect(Collectors.toSet());
    }
}
