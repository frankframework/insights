package org.frankframework.insights.vulnerability;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;

    @Mock
    private ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    @Mock
    private ReleaseRepository releaseRepository;

    @Mock
    private ReleaseArtifactService releaseArtifactService;

    @Mock
    private Mapper mapper;

    private VulnerabilityService vulnerabilityService;

    private Release release;

    @BeforeEach
    public void setUp() {
        vulnerabilityService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp/trivy-scan",
                "/tmp/trivy-cache");

        release = new Release();
        release.setId("release-1");
        release.setName("Test Release");
        release.setTagName("v1.0.0");
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_Success() {
        String releaseId = "release-123";
        Vulnerability vuln = new Vulnerability();
        vuln.setCveId("CVE-2023-0001");
        ReleaseVulnerability link = new ReleaseVulnerability(release, vuln);
        VulnerabilityResponse response =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link));
        when(mapper.toDTO(vuln, VulnerabilityResponse.class)).thenReturn(response);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.contains(response));
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_NoLinks() {
        String releaseId = "release-456";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_NullOrBlankId() {
        Set<VulnerabilityResponse> resultNull = vulnerabilityService.getVulnerabilitiesByReleaseId(null);
        assertTrue(resultNull.isEmpty());

        Set<VulnerabilityResponse> resultBlank = vulnerabilityService.getVulnerabilitiesByReleaseId("  ");
        assertTrue(resultBlank.isEmpty());

        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_RepoThrowsException() {
        String releaseId = "release-ex";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetAllVulnerabilities_Success() {
        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        vuln1.setSeverity(VulnerabilitySeverity.HIGH);
        vuln1.setCvssScore(7.5);

        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        vuln2.setSeverity(VulnerabilitySeverity.CRITICAL);
        vuln2.setCvssScore(9.8);

        VulnerabilityResponse response1 =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc1", null, null, null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002", VulnerabilitySeverity.CRITICAL, 9.8, "Desc2", null, null, null);

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln1, vuln2));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertEquals(2, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_EmptyList() {
        when(vulnerabilityRepository.findAll()).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_RepoThrowsException() {
        when(vulnerabilityRepository.findAll()).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testUpdateVulnerabilityImpact_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(8.5, "High impact on production");

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setSeverity(VulnerabilitySeverity.HIGH);
        existingVuln.setCvssScore(7.5);
        existingVuln.setDescription("Original description");

        Vulnerability savedVuln = new Vulnerability();
        savedVuln.setCveId(cveId);
        savedVuln.setSeverity(VulnerabilitySeverity.HIGH);
        savedVuln.setCvssScore(7.5);
        savedVuln.setDescription("Original description");
        savedVuln.setImpactScore(8.5);
        savedVuln.setImpactDescription("High impact on production");

        VulnerabilityResponse expectedResponse = new VulnerabilityResponse(
                cveId, VulnerabilitySeverity.HIGH, 7.5, "Original description", null, 8.5, "High impact on production");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));
        when(vulnerabilityRepository.save(any(Vulnerability.class))).thenReturn(savedVuln);
        when(mapper.toDTO(savedVuln, VulnerabilityResponse.class)).thenReturn(expectedResponse);

        VulnerabilityResponse result = vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest);

        assertNotNull(result);
        assertEquals(cveId, result.cveId());
        assertEquals(8.5, result.impactScore());
        assertEquals("High impact on production", result.impactDescription());

        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, times(1)).save(any(Vulnerability.class));
        verify(mapper, times(1)).toDTO(savedVuln, VulnerabilityResponse.class);
    }

    @Test
    public void testUpdateVulnerabilityImpact_NotFound() {
        String cveId = "CVE-NOT-EXIST";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, "Some impact");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.empty());

        VulnerabilityNotFoundException exception = assertThrows(
                VulnerabilityNotFoundException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Vulnerability not found: " + cveId));
        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_NullRequest_ThrowsException() {
        String cveId = "CVE-2023-1234";

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class, () -> vulnerabilityService.updateVulnerabilityImpact(cveId, null));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).findById(any());
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_WithNullImpactScore_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(null, "Some description");

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).findById(any());
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_WithNullDescription_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, null);

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testDeleteVulnerabilityImpact_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-DELETE";
        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(9.0);
        existingVuln.setImpactDescription("To be deleted");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));

        vulnerabilityService.deleteVulnerabilityImpact(cveId);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        assertEquals(cveId, savedVuln.getCveId());
        Assertions.assertNull(savedVuln.getImpactScore());
        Assertions.assertNull(savedVuln.getImpactDescription());
    }

    @Test
    public void testDeleteVulnerabilityImpact_NotFound() {
        String cveId = "CVE-UNKNOWN";
        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.empty());

        assertThrows(VulnerabilityNotFoundException.class, () -> vulnerabilityService.deleteVulnerabilityImpact(cveId));

        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_WithMultipleVulnerabilities() {
        String releaseId = "release-multi";

        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        Vulnerability vuln3 = new Vulnerability();
        vuln3.setCveId("CVE-2023-0003");

        ReleaseVulnerability link1 = new ReleaseVulnerability(release, vuln1);
        ReleaseVulnerability link2 = new ReleaseVulnerability(release, vuln2);
        ReleaseVulnerability link3 = new ReleaseVulnerability(release, vuln3);

        VulnerabilityResponse response1 =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc1", null, null, null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002", VulnerabilitySeverity.MEDIUM, 5.0, "Desc2", null, null, null);
        VulnerabilityResponse response3 = new VulnerabilityResponse(
                "CVE-2023-0003", VulnerabilitySeverity.CRITICAL, 9.8, "Desc3", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link1, link2, link3));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);
        when(mapper.toDTO(vuln3, VulnerabilityResponse.class)).thenReturn(response3);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(3, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        assertTrue(result.contains(response3));
    }

    @Test
    public void testScanAndSaveVulnerabilitiesForAllReleases_WithNoReleases() throws IOException {
        when(releaseRepository.findAll()).thenReturn(Collections.emptyList());

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseRepository, times(1)).findAll();
        verify(releaseArtifactService, never()).downloadReleaseZipToPvc(any());
    }

    @Test
    public void testScanAndSaveVulnerabilitiesForAllReleases_SortsReleasesByLastScanned() throws IOException {
        Release releaseScannedRecently = new Release();
        releaseScannedRecently.setId("release-recent");
        releaseScannedRecently.setTagName("v2.0.0");
        releaseScannedRecently.setLastScanned(java.time.OffsetDateTime.now());

        Release releaseNeverScanned = new Release();
        releaseNeverScanned.setId("release-never");
        releaseNeverScanned.setTagName("v1.0.0");
        releaseNeverScanned.setLastScanned(null);

        when(releaseRepository.findAll()).thenReturn(List.of(releaseScannedRecently, releaseNeverScanned));
        when(releaseArtifactService.downloadReleaseZipToPvc(any()))
                .thenThrow(new IOException("Test - stop processing"));

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseArtifactService).downloadReleaseZipToPvc("v1.0.0");
    }

    @Test
    public void testScanAndSaveVulnerabilitiesForAllReleases_ContinuesOnError() throws IOException {
        Release release1 = new Release();
        release1.setId("release-1");
        release1.setTagName("v1.0.0");
        release1.setLastScanned(null);

        Release release2 = new Release();
        release2.setId("release-2");
        release2.setTagName("v2.0.0");
        release2.setLastScanned(null);

        when(releaseRepository.findAll()).thenReturn(List.of(release1, release2));
        when(releaseArtifactService.downloadReleaseZipToPvc("v1.0.0")).thenThrow(new IOException("Download failed"));
        when(releaseArtifactService.downloadReleaseZipToPvc("v2.0.0")).thenThrow(new IOException("Download failed"));

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseArtifactService).downloadReleaseZipToPvc("v1.0.0");
        verify(releaseArtifactService).downloadReleaseZipToPvc("v2.0.0");
    }

    @Test
    public void testUpdateVulnerabilityImpact_UpdatesExistingFields() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-UPDATE";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(6.0, "Updated impact");

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(3.0);
        existingVuln.setImpactDescription("Old impact");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));
        when(vulnerabilityRepository.save(any(Vulnerability.class))).thenAnswer(inv -> inv.getArgument(0));
        when(mapper.toDTO(any(Vulnerability.class), any()))
                .thenReturn(new VulnerabilityResponse(
                        cveId, VulnerabilitySeverity.MEDIUM, 5.0, "Desc", null, 6.0, "Updated impact"));

        vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        assertEquals(6.0, savedVuln.getImpactScore());
        assertEquals("Updated impact", savedVuln.getImpactDescription());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_WithEmptyString() {
        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId("");
        assertTrue(result.isEmpty());
        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void testDeleteVulnerabilityImpact_ClearsExistingImpact() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-CLEAR";
        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(9.5);
        existingVuln.setImpactDescription("Critical impact");
        existingVuln.setSeverity(VulnerabilitySeverity.CRITICAL);
        existingVuln.setCvssScore(9.8);

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));

        vulnerabilityService.deleteVulnerabilityImpact(cveId);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        Assertions.assertNull(savedVuln.getImpactScore());
        Assertions.assertNull(savedVuln.getImpactDescription());
        assertEquals(VulnerabilitySeverity.CRITICAL, savedVuln.getSeverity());
        assertEquals(9.8, savedVuln.getCvssScore());
    }

    @Test
    public void testGetAllVulnerabilities_WithMixedSeverities() {
        Vulnerability low = new Vulnerability();
        low.setCveId("CVE-LOW");
        low.setSeverity(VulnerabilitySeverity.LOW);

        Vulnerability medium = new Vulnerability();
        medium.setCveId("CVE-MEDIUM");
        medium.setSeverity(VulnerabilitySeverity.MEDIUM);

        Vulnerability high = new Vulnerability();
        high.setCveId("CVE-HIGH");
        high.setSeverity(VulnerabilitySeverity.HIGH);

        Vulnerability critical = new Vulnerability();
        critical.setCveId("CVE-CRITICAL");
        critical.setSeverity(VulnerabilitySeverity.CRITICAL);

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(low, medium, high, critical));
        when(mapper.toDTO(any(Vulnerability.class), any())).thenAnswer(inv -> {
            Vulnerability v = inv.getArgument(0);
            return new VulnerabilityResponse(v.getCveId(), v.getSeverity(), 0.0, "Desc", null, null, null);
        });

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertEquals(4, result.size());
    }

    @Test
    public void testUnzipAndFilter_WithValidZip_ExtractsFiles(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry entry = new ZipEntry("pom.xml");
            zos.putNextEntry(entry);
            zos.write("<project></project>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertTrue(Files.exists(extractDir.resolve("pom.xml")));
    }

    @Test
    public void testUnzipAndFilter_SkipsJavaFiles(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry javaEntry = new ZipEntry("Main.java");
            zos.putNextEntry(javaEntry);
            zos.write("public class Main {}".getBytes());
            zos.closeEntry();

            ZipEntry pomEntry = new ZipEntry("pom.xml");
            zos.putNextEntry(pomEntry);
            zos.write("<project></project>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(extractDir.resolve("Main.java")));
        assertTrue(Files.exists(extractDir.resolve("pom.xml")));
    }

    @Test
    public void testUnzipAndFilter_SkipsTestFolders(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry testEntry = new ZipEntry("src/test/resources/test.xml");
            zos.putNextEntry(testEntry);
            zos.write("<test></test>".getBytes());
            zos.closeEntry();

            ZipEntry mainEntry = new ZipEntry("src/main/resources/config.xml");
            zos.putNextEntry(mainEntry);
            zos.write("<config></config>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(extractDir.resolve("src/test/resources/test.xml")));
        assertTrue(Files.exists(extractDir.resolve("src/main/resources/config.xml")));
    }

    @Test
    public void testUnzipAndFilter_PreventsZipSlip(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("malicious.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry maliciousEntry = new ZipEntry("../../../etc/passwd");
            zos.putNextEntry(maliciousEntry);
            zos.write("malicious content".getBytes());
            zos.closeEntry();

            ZipEntry normalEntry = new ZipEntry("normal.xml");
            zos.putNextEntry(normalEntry);
            zos.write("<normal></normal>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(tempDir.resolve("etc/passwd")));
        assertTrue(Files.exists(extractDir.resolve("normal.xml")));
    }

    @Test
    public void testUnzipAndFilter_CreatesDirectories(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry dirEntry = new ZipEntry("nested/dir/");
            zos.putNextEntry(dirEntry);
            zos.closeEntry();

            ZipEntry fileEntry = new ZipEntry("nested/dir/file.xml");
            zos.putNextEntry(fileEntry);
            zos.write("<file></file>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertTrue(Files.exists(extractDir.resolve("nested/dir")));
        assertTrue(Files.isDirectory(extractDir.resolve("nested/dir")));
        assertTrue(Files.exists(extractDir.resolve("nested/dir/file.xml")));
    }

    @Test
    public void testUnzipAndFilter_SkipsImageFiles(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry pngEntry = new ZipEntry("image.png");
            zos.putNextEntry(pngEntry);
            zos.write(new byte[] {(byte) 0x89, 0x50, 0x4E, 0x47});
            zos.closeEntry();

            ZipEntry jpgEntry = new ZipEntry("photo.jpg");
            zos.putNextEntry(jpgEntry);
            zos.write(new byte[] {(byte) 0xFF, (byte) 0xD8, (byte) 0xFF});
            zos.closeEntry();

            ZipEntry xmlEntry = new ZipEntry("config.xml");
            zos.putNextEntry(xmlEntry);
            zos.write("<config></config>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(extractDir.resolve("image.png")));
        assertFalse(Files.exists(extractDir.resolve("photo.jpg")));
        assertTrue(Files.exists(extractDir.resolve("config.xml")));
    }

    @Test
    public void testShouldSkipExtension_VariousExtensions() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipExtension", String.class);
        method.setAccessible(true);

        assertTrue((Boolean) method.invoke(testService, "Test.java"));
        assertTrue((Boolean) method.invoke(testService, "script.py"));
        assertTrue((Boolean) method.invoke(testService, "image.png"));
        assertTrue((Boolean) method.invoke(testService, "document.pdf"));
        assertTrue((Boolean) method.invoke(testService, "style.css"));
        assertFalse((Boolean) method.invoke(testService, "pom.xml"));
        assertFalse((Boolean) method.invoke(testService, "build.gradle"));
        assertFalse((Boolean) method.invoke(testService, "package.json"));
    }

    @Test
    public void testShouldSkipFolder_VariousFolders() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipFolder", String.class);
        method.setAccessible(true);

        assertTrue((Boolean) method.invoke(testService, "src/test/java/Test.xml"));
        assertTrue((Boolean) method.invoke(testService, "node_modules/package/index.js"));
        assertTrue((Boolean) method.invoke(testService, ".git/config"));
        assertFalse((Boolean) method.invoke(testService, "src/main/resources/config.xml"));
        assertFalse((Boolean) method.invoke(testService, "lib/dependency.jar"));
    }

    @Test
    public void testShouldSkipExtension_FileWithoutExtension() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipExtension", String.class);
        method.setAccessible(true);

        assertFalse((Boolean) method.invoke(testService, "Dockerfile"));
        assertFalse((Boolean) method.invoke(testService, "Makefile"));
        assertFalse((Boolean) method.invoke(testService, "README"));
        assertFalse((Boolean) method.invoke(testService, ".hidden"));
    }

    @Test
    public void testShouldSkipExtension_CaseInsensitive() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipExtension", String.class);
        method.setAccessible(true);

        assertTrue((Boolean) method.invoke(testService, "Test.JAVA"));
        assertTrue((Boolean) method.invoke(testService, "image.PNG"));
        assertTrue((Boolean) method.invoke(testService, "style.CSS"));
        assertTrue((Boolean) method.invoke(testService, "document.PDF"));
    }

    @Test
    public void testShouldSkipFolder_WithBackslashes() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipFolder", String.class);
        method.setAccessible(true);

        assertTrue((Boolean) method.invoke(testService, "src\\test\\java\\Test.xml"));
        assertTrue((Boolean) method.invoke(testService, "node_modules\\package\\index.js"));
        assertTrue((Boolean) method.invoke(testService, ".git\\config"));
    }

    @Test
    public void testUnzipAndFilter_SkipsDocsFolders(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry docsEntry = new ZipEntry("docs/api.xml");
            zos.putNextEntry(docsEntry);
            zos.write("<api></api>".getBytes());
            zos.closeEntry();

            ZipEntry javadocEntry = new ZipEntry("target/apidocs/index.xml");
            zos.putNextEntry(javadocEntry);
            zos.write("<index></index>".getBytes());
            zos.closeEntry();

            ZipEntry mainEntry = new ZipEntry("src/main/config.xml");
            zos.putNextEntry(mainEntry);
            zos.write("<config></config>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(extractDir.resolve("target/apidocs/index.xml")));
        assertTrue(Files.exists(extractDir.resolve("src/main/config.xml")));
    }

    @Test
    public void testUnzipAndFilter_SkipsVariousExtensions(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            String[] skipExts = {
                ".cpp",
                ".c",
                ".h",
                ".py",
                ".go",
                ".ts",
                ".js",
                ".sh",
                ".bat",
                ".gif",
                ".svg",
                ".ico",
                ".webp",
                ".doc",
                ".docx",
                ".xls",
                ".xlsx",
                ".ppt",
                ".pptx",
                ".txt",
                ".md",
                ".rtf",
                ".csv",
                ".xsd",
                ".wsdl",
                ".properties",
                ".sql",
                ".conf",
                ".policy",
                ".editorconfig",
                ".gitignore",
                ".dockerignore",
                ".scss",
                ".less",
                ".sass",
                ".html",
                ".htm",
                ".xhtml",
                ".jks",
                ".p12",
                ".pfx",
                ".cer",
                ".crt",
                ".key",
                ".pem",
                ".asc",
                ".tar",
                ".gz",
                ".7z",
                ".rar",
                ".woff",
                ".woff2",
                ".eot",
                ".ttf",
                ".otf"
            };

            for (String ext : skipExts) {
                ZipEntry entry = new ZipEntry("file" + ext);
                zos.putNextEntry(entry);
                zos.write("content".getBytes());
                zos.closeEntry();
            }

            ZipEntry xmlEntry = new ZipEntry("pom.xml");
            zos.putNextEntry(xmlEntry);
            zos.write("<project></project>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertTrue(Files.exists(extractDir.resolve("pom.xml")));
        assertFalse(Files.exists(extractDir.resolve("file.cpp")));
        assertFalse(Files.exists(extractDir.resolve("file.py")));
        assertFalse(Files.exists(extractDir.resolve("file.html")));
    }

    @Test
    public void testParseTrivyOutput_NullInput() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("parseTrivyOutput", String.class);
        method.setAccessible(true);

        TrivyReport result = (TrivyReport) method.invoke(testService, (String) null);
        assertNotNull(result);
    }

    @Test
    public void testParseTrivyOutput_BlankInput() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("parseTrivyOutput", String.class);
        method.setAccessible(true);

        TrivyReport result = (TrivyReport) method.invoke(testService, "   ");
        assertNotNull(result);
    }

    @Test
    public void testParseVulnerabilitiesFromReport_NullReport() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("parseVulnerabilitiesFromReport", TrivyReport.class);
        method.setAccessible(true);

        @SuppressWarnings("unchecked")
        List<TrivyVulnerability> result = (List<TrivyVulnerability>) method.invoke(testService, (TrivyReport) null);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testParseVulnerabilitiesFromReport_NullResults() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("parseVulnerabilitiesFromReport", TrivyReport.class);
        method.setAccessible(true);

        TrivyReport report = new TrivyReport();
        report.Results = null;

        @SuppressWarnings("unchecked")
        List<TrivyVulnerability> result = (List<TrivyVulnerability>) method.invoke(testService, report);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testParseVulnerabilitiesFromReport_WithNullVulnerabilities() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("parseVulnerabilitiesFromReport", TrivyReport.class);
        method.setAccessible(true);

        TrivyReport report = new TrivyReport();
        TrivyResult resultWithNullVulns = new TrivyResult("target", "class", "type", null);
        report.Results = List.of(resultWithNullVulns);

        @SuppressWarnings("unchecked")
        List<TrivyVulnerability> result = (List<TrivyVulnerability>) method.invoke(testService, report);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testParseVulnerabilitiesFromReport_FiltersNullVulnerabilities() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("parseVulnerabilitiesFromReport", TrivyReport.class);
        method.setAccessible(true);

        TrivyVulnerability validVuln = new TrivyVulnerability("CVE-2023-0001", "Title", "Desc", "HIGH", null, null);
        TrivyReport report = new TrivyReport();
        TrivyResult resultWithMixedVulns =
                new TrivyResult("target", "class", "type", java.util.Arrays.asList(validVuln, null, validVuln));
        report.Results = List.of(resultWithMixedVulns);

        @SuppressWarnings("unchecked")
        List<TrivyVulnerability> result = (List<TrivyVulnerability>) method.invoke(testService, report);
        assertNotNull(result);
        assertEquals(2, result.size());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_WithNullVulnerabilityInLink() {
        String releaseId = "release-with-null";
        ReleaseVulnerability linkWithNull = new ReleaseVulnerability();
        linkWithNull.setRelease(release);
        linkWithNull.setVulnerability(null);

        Vulnerability validVuln = new Vulnerability();
        validVuln.setCveId("CVE-2023-0001");
        ReleaseVulnerability validLink = new ReleaseVulnerability(release, validVuln);

        VulnerabilityResponse response =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(linkWithNull, validLink));
        when(mapper.toDTO(validVuln, VulnerabilityResponse.class)).thenReturn(response);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.contains(response));
    }

    @Test
    public void testShouldSkipFolder_SkipsAllDefinedFolders() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipFolder", String.class);
        method.setAccessible(true);

        assertTrue((Boolean) method.invoke(testService, "project/tests/unit/test.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/testing/integration.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/doc/readme.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/documentation/guide.xml"));
        assertTrue((Boolean) method.invoke(testService, "target/site/index.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/samples/example.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/examples/demo.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/demo/app.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/demos/app.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/mock/service.xml"));
        assertTrue((Boolean) method.invoke(testService, "project/mocks/service.xml"));
        assertTrue((Boolean) method.invoke(testService, ".idea/workspace.xml"));
        assertTrue((Boolean) method.invoke(testService, ".vscode/settings.json"));
        assertTrue((Boolean) method.invoke(testService, ".mvn/wrapper/maven-wrapper.jar"));
        assertTrue((Boolean) method.invoke(testService, "project/assets/image.xml"));
    }

    @Test
    public void testUnzipAndFilter_HandlesNestedDirectoryStructure(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("nested.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry dir1 = new ZipEntry("level1/");
            zos.putNextEntry(dir1);
            zos.closeEntry();

            ZipEntry dir2 = new ZipEntry("level1/level2/");
            zos.putNextEntry(dir2);
            zos.closeEntry();

            ZipEntry dir3 = new ZipEntry("level1/level2/level3/");
            zos.putNextEntry(dir3);
            zos.closeEntry();

            ZipEntry fileEntry = new ZipEntry("level1/level2/level3/config.xml");
            zos.putNextEntry(fileEntry);
            zos.write("<config></config>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertTrue(Files.exists(extractDir.resolve("level1/level2/level3/config.xml")));
        assertTrue(Files.isDirectory(extractDir.resolve("level1")));
        assertTrue(Files.isDirectory(extractDir.resolve("level1/level2")));
        assertTrue(Files.isDirectory(extractDir.resolve("level1/level2/level3")));
    }

    @Test
    public void testUnzipAndFilter_CreatesParentDirectoriesForFile(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("nodir.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry fileEntry = new ZipEntry("deep/nested/path/config.xml");
            zos.putNextEntry(fileEntry);
            zos.write("<config></config>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertTrue(Files.exists(extractDir.resolve("deep/nested/path/config.xml")));
    }

    @Test
    public void testMapTrivyVulnerabilityToEntity_WithNullInput() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "mapTrivyVulnerabilityToEntity", TrivyVulnerability.class, java.util.Map.class);
        method.setAccessible(true);

        Vulnerability result = (Vulnerability) method.invoke(testService, null, new java.util.HashMap<>());
        Assertions.assertNull(result);
    }

    @Test
    public void testMapTrivyVulnerabilityToEntity_WithNullVulnerabilityID() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "mapTrivyVulnerabilityToEntity", TrivyVulnerability.class, java.util.Map.class);
        method.setAccessible(true);

        TrivyVulnerability vulnWithNullId = new TrivyVulnerability(null, "Title", "Desc", "HIGH", null, null);
        Vulnerability result = (Vulnerability) method.invoke(testService, vulnWithNullId, new java.util.HashMap<>());
        Assertions.assertNull(result);
    }

    @Test
    public void testMapTrivyVulnerabilityToEntity_CreatesNewVulnerability() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "mapTrivyVulnerabilityToEntity", TrivyVulnerability.class, java.util.Map.class);
        method.setAccessible(true);

        TrivyVulnerability trivyVuln = new TrivyVulnerability(
                "CVE-2023-NEW", "New Vulnerability", "Description", "CRITICAL", List.of("CWE-79", "CWE-89"), null);

        java.util.Map<String, Vulnerability> existingMap = new java.util.HashMap<>();

        Vulnerability result = (Vulnerability) method.invoke(testService, trivyVuln, existingMap);

        assertNotNull(result);
        assertEquals("CVE-2023-NEW", result.getCveId());
        assertEquals(VulnerabilitySeverity.CRITICAL, result.getSeverity());
        assertTrue(result.getCwes().contains("CWE-79"));
        assertTrue(result.getCwes().contains("CWE-89"));
    }

    @Test
    public void testMapTrivyVulnerabilityToEntity_UpdatesExistingVulnerability() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "mapTrivyVulnerabilityToEntity", TrivyVulnerability.class, java.util.Map.class);
        method.setAccessible(true);

        Vulnerability existing = new Vulnerability();
        existing.setCveId("CVE-2023-EXIST");
        existing.setSeverity(VulnerabilitySeverity.MEDIUM);

        java.util.Map<String, Vulnerability> existingMap = new java.util.HashMap<>();
        existingMap.put("CVE-2023-EXIST", existing);

        TrivyVulnerability trivyVuln =
                new TrivyVulnerability("CVE-2023-EXIST", "Updated Title", "Updated Desc", "HIGH", null, null);

        Vulnerability result = (Vulnerability) method.invoke(testService, trivyVuln, existingMap);

        assertNotNull(result);
        assertEquals(existing, result);
        assertEquals(VulnerabilitySeverity.HIGH, result.getSeverity());
    }

    @Test
    public void testGetCveIdsFromReport_FiltersNullIds() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("getCveIdsFromReport", List.class);
        method.setAccessible(true);

        TrivyVulnerability vuln1 = new TrivyVulnerability("CVE-2023-0001", "Title1", "Desc1", "HIGH", null, null);
        TrivyVulnerability vulnNullId = new TrivyVulnerability(null, "Title2", "Desc2", "MEDIUM", null, null);
        TrivyVulnerability vuln2 = new TrivyVulnerability("CVE-2023-0002", "Title3", "Desc3", "LOW", null, null);

        @SuppressWarnings("unchecked")
        Set<String> result = (Set<String>) method.invoke(testService, List.of(vuln1, vulnNullId, vuln2));

        assertEquals(2, result.size());
        assertTrue(result.contains("CVE-2023-0001"));
        assertTrue(result.contains("CVE-2023-0002"));
        assertFalse(result.contains(null));
    }

    @Test
    public void testGetEffectiveCvssScore_UsesExistingScore() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "getEffectiveCvssScore", TrivyVulnerability.class, VulnerabilitySeverity.class, Double.class);
        method.setAccessible(true);

        TrivyVulnerability vulnWithoutCvss =
                new TrivyVulnerability("CVE-2023-0001", "Title", "Desc", "HIGH", null, null);

        Double result = (Double) method.invoke(testService, vulnWithoutCvss, VulnerabilitySeverity.HIGH, 8.5);

        assertEquals(8.5, result);
    }

    @Test
    public void testGetEffectiveCvssScore_UsesSeverityRepresentativeScore() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "getEffectiveCvssScore", TrivyVulnerability.class, VulnerabilitySeverity.class, Double.class);
        method.setAccessible(true);

        TrivyVulnerability vulnWithoutCvss =
                new TrivyVulnerability("CVE-2023-0001", "Title", "Desc", "HIGH", null, null);

        Double result = (Double) method.invoke(testService, vulnWithoutCvss, VulnerabilitySeverity.HIGH, null);

        assertEquals(VulnerabilitySeverity.HIGH.getRepresentativeScore(), result);
    }

    @Test
    public void testGetEffectiveCvssScore_UsesTrivyScore() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "getEffectiveCvssScore", TrivyVulnerability.class, VulnerabilitySeverity.class, Double.class);
        method.setAccessible(true);

        java.util.Map<String, TrivyCvssScore> cvssMap = new java.util.HashMap<>();
        cvssMap.put("nvd", new TrivyCvssScore(null, null, 9.1, null));

        TrivyVulnerability vulnWithCvss =
                new TrivyVulnerability("CVE-2023-0001", "Title", "Desc", "CRITICAL", null, cvssMap);

        Double result = (Double) method.invoke(testService, vulnWithCvss, VulnerabilitySeverity.CRITICAL, 8.0);

        assertEquals(9.1, result);
    }

    @Test
    public void testHandleEmptyScanResult_DeletesExistingLinks() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("handleEmptyScanResult", Release.class);
        method.setAccessible(true);

        Release testRelease = new Release();
        testRelease.setId("test-release-id");
        testRelease.setTagName("v1.0.0");

        method.invoke(testService, testRelease);

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId("test-release-id");
    }

    @Test
    public void testUpdateReleaseVulnerabilityLinks_WithEmptyVulnerabilities() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "updateReleaseVulnerabilityLinks", Release.class, Set.class);
        method.setAccessible(true);

        Release testRelease = new Release();
        testRelease.setId("test-release-id");

        method.invoke(testService, testRelease, Collections.emptySet());

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId("test-release-id");
        verify(releaseVulnerabilityRepository, never()).saveAll(any());
    }

    @Test
    public void testUpdateReleaseVulnerabilityLinks_SavesNewLinks() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method = VulnerabilityService.class.getDeclaredMethod(
                "updateReleaseVulnerabilityLinks", Release.class, Set.class);
        method.setAccessible(true);

        Release testRelease = new Release();
        testRelease.setId("test-release-id");

        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");

        Set<Vulnerability> vulnerabilities = Set.of(vuln1, vuln2);

        method.invoke(testService, testRelease, vulnerabilities);

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId("test-release-id");

        @SuppressWarnings("unchecked")
        ArgumentCaptor<List<ReleaseVulnerability>> captor = ArgumentCaptor.forClass(List.class);
        verify(releaseVulnerabilityRepository).saveAll(captor.capture());

        List<ReleaseVulnerability> savedLinks = captor.getValue();
        assertEquals(2, savedLinks.size());
    }

    @Test
    public void testScanWithSlashInTagName_CallsDownloadWithCorrectTagName() throws IOException {
        Release releaseWithSlash = new Release();
        releaseWithSlash.setId("release-slash");
        releaseWithSlash.setName("Feature Snapshot");
        releaseWithSlash.setTagName("feature/snapshot");

        Path mockZipPath = Paths.get("/tmp/trivy-scan/feature-snapshot.zip");

        when(releaseRepository.findAll()).thenReturn(List.of(releaseWithSlash));
        when(releaseArtifactService.downloadReleaseZipToPvc("feature/snapshot")).thenReturn(mockZipPath);

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class)) {
            mockedFiles.when(() -> Files.createDirectories(any(Path.class))).thenReturn(null);
            mockedFiles
                    .when(() -> Files.copy(any(Path.class), any(Path.class), eq(StandardCopyOption.REPLACE_EXISTING)))
                    .thenReturn(null);

            try {
                vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();
            } catch (Exception ignored) {
                // Expected - trivy execution will fail in test environment
            }

            verify(releaseArtifactService).downloadReleaseZipToPvc("feature/snapshot");

            ArgumentCaptor<Path> destCaptor = ArgumentCaptor.forClass(Path.class);
            mockedFiles.verify(
                    () -> Files.copy(any(Path.class), destCaptor.capture(), eq(StandardCopyOption.REPLACE_EXISTING)));

            Path capturedDest = destCaptor.getValue();
            assertTrue(
                    capturedDest.toString().contains("feature-snapshot.zip"),
                    "Expected safe filename with dash instead of slash, got: " + capturedDest);
        }
    }
}
