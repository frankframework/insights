package org.frankframework.insights.vulnerability;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;

    @Mock
    private ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    @Mock
    private ReleaseRepository releaseRepository;

    @Mock
    private ReleaseArtifactService releaseArtifactService;

    @Mock
    private Mapper mapper;

    private VulnerabilityService vulnerabilityService;

    private Release release;

    @BeforeEach
    public void setUp() {
        vulnerabilityService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp/trivy-scan",
                "/tmp/trivy-cache");

        release = new Release();
        release.setId("release-1");
        release.setName("Test Release");
        release.setTagName("v1.0.0");
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_Success() {
        String releaseId = "release-123";
        Vulnerability vuln = new Vulnerability();
        vuln.setCveId("CVE-2023-0001");
        ReleaseVulnerability link = new ReleaseVulnerability(release, vuln);
        VulnerabilityResponse response =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link));
        when(mapper.toDTO(vuln, VulnerabilityResponse.class)).thenReturn(response);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.contains(response));
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_NoLinks() {
        String releaseId = "release-456";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_NullOrBlankId() {
        Set<VulnerabilityResponse> resultNull = vulnerabilityService.getVulnerabilitiesByReleaseId(null);
        assertTrue(resultNull.isEmpty());

        Set<VulnerabilityResponse> resultBlank = vulnerabilityService.getVulnerabilitiesByReleaseId("  ");
        assertTrue(resultBlank.isEmpty());

        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_RepoThrowsException() {
        String releaseId = "release-ex";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetAllVulnerabilities_Success() {
        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        vuln1.setSeverity(VulnerabilitySeverity.HIGH);
        vuln1.setCvssScore(7.5);

        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        vuln2.setSeverity(VulnerabilitySeverity.CRITICAL);
        vuln2.setCvssScore(9.8);

        VulnerabilityResponse response1 =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc1", null, null, null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002", VulnerabilitySeverity.CRITICAL, 9.8, "Desc2", null, null, null);

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln1, vuln2));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertEquals(2, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_EmptyList() {
        when(vulnerabilityRepository.findAll()).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_RepoThrowsException() {
        when(vulnerabilityRepository.findAll()).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testUpdateVulnerabilityImpact_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(8.5, "High impact on production");

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setSeverity(VulnerabilitySeverity.HIGH);
        existingVuln.setCvssScore(7.5);
        existingVuln.setDescription("Original description");

        Vulnerability savedVuln = new Vulnerability();
        savedVuln.setCveId(cveId);
        savedVuln.setSeverity(VulnerabilitySeverity.HIGH);
        savedVuln.setCvssScore(7.5);
        savedVuln.setDescription("Original description");
        savedVuln.setImpactScore(8.5);
        savedVuln.setImpactDescription("High impact on production");

        VulnerabilityResponse expectedResponse = new VulnerabilityResponse(
                cveId, VulnerabilitySeverity.HIGH, 7.5, "Original description", null, 8.5, "High impact on production");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));
        when(vulnerabilityRepository.save(any(Vulnerability.class))).thenReturn(savedVuln);
        when(mapper.toDTO(savedVuln, VulnerabilityResponse.class)).thenReturn(expectedResponse);

        VulnerabilityResponse result = vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest);

        assertNotNull(result);
        assertEquals(cveId, result.cveId());
        assertEquals(8.5, result.impactScore());
        assertEquals("High impact on production", result.impactDescription());

        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, times(1)).save(any(Vulnerability.class));
        verify(mapper, times(1)).toDTO(savedVuln, VulnerabilityResponse.class);
    }

    @Test
    public void testUpdateVulnerabilityImpact_NotFound() {
        String cveId = "CVE-NOT-EXIST";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, "Some impact");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.empty());

        VulnerabilityNotFoundException exception = assertThrows(
                VulnerabilityNotFoundException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Vulnerability not found: " + cveId));
        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_NullRequest_ThrowsException() {
        String cveId = "CVE-2023-1234";

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class, () -> vulnerabilityService.updateVulnerabilityImpact(cveId, null));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).findById(any());
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_WithNullImpactScore_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(null, "Some description");

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).findById(any());
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_WithNullDescription_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, null);

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testDeleteVulnerabilityImpact_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-DELETE";
        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(9.0);
        existingVuln.setImpactDescription("To be deleted");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));

        vulnerabilityService.deleteVulnerabilityImpact(cveId);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        assertEquals(cveId, savedVuln.getCveId());
        Assertions.assertNull(savedVuln.getImpactScore());
        Assertions.assertNull(savedVuln.getImpactDescription());
    }

    @Test
    public void testDeleteVulnerabilityImpact_NotFound() {
        String cveId = "CVE-UNKNOWN";
        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.empty());

        assertThrows(VulnerabilityNotFoundException.class, () -> vulnerabilityService.deleteVulnerabilityImpact(cveId));

        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_WithMultipleVulnerabilities() {
        String releaseId = "release-multi";

        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        Vulnerability vuln3 = new Vulnerability();
        vuln3.setCveId("CVE-2023-0003");

        ReleaseVulnerability link1 = new ReleaseVulnerability(release, vuln1);
        ReleaseVulnerability link2 = new ReleaseVulnerability(release, vuln2);
        ReleaseVulnerability link3 = new ReleaseVulnerability(release, vuln3);

        VulnerabilityResponse response1 =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc1", null, null, null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002", VulnerabilitySeverity.MEDIUM, 5.0, "Desc2", null, null, null);
        VulnerabilityResponse response3 = new VulnerabilityResponse(
                "CVE-2023-0003", VulnerabilitySeverity.CRITICAL, 9.8, "Desc3", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link1, link2, link3));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);
        when(mapper.toDTO(vuln3, VulnerabilityResponse.class)).thenReturn(response3);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(3, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        assertTrue(result.contains(response3));
    }

    @Test
    public void testScanAndSaveVulnerabilitiesForAllReleases_WithNoReleases() throws IOException {
        when(releaseRepository.findAll()).thenReturn(Collections.emptyList());

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseRepository, times(1)).findAll();
        verify(releaseArtifactService, never()).downloadReleaseZipToPvc(any());
    }

    @Test
    public void testScanAndSaveVulnerabilitiesForAllReleases_SortsReleasesByLastScanned() throws IOException {
        Release releaseScannedRecently = new Release();
        releaseScannedRecently.setId("release-recent");
        releaseScannedRecently.setTagName("v2.0.0");
        releaseScannedRecently.setLastScanned(java.time.OffsetDateTime.now());

        Release releaseNeverScanned = new Release();
        releaseNeverScanned.setId("release-never");
        releaseNeverScanned.setTagName("v1.0.0");
        releaseNeverScanned.setLastScanned(null);

        when(releaseRepository.findAll()).thenReturn(List.of(releaseScannedRecently, releaseNeverScanned));
        when(releaseArtifactService.downloadReleaseZipToPvc(any()))
                .thenThrow(new IOException("Test - stop processing"));

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseArtifactService).downloadReleaseZipToPvc("v1.0.0");
    }

    @Test
    public void testScanAndSaveVulnerabilitiesForAllReleases_ContinuesOnError() throws IOException {
        Release release1 = new Release();
        release1.setId("release-1");
        release1.setTagName("v1.0.0");
        release1.setLastScanned(null);

        Release release2 = new Release();
        release2.setId("release-2");
        release2.setTagName("v2.0.0");
        release2.setLastScanned(null);

        when(releaseRepository.findAll()).thenReturn(List.of(release1, release2));
        when(releaseArtifactService.downloadReleaseZipToPvc("v1.0.0")).thenThrow(new IOException("Download failed"));
        when(releaseArtifactService.downloadReleaseZipToPvc("v2.0.0")).thenThrow(new IOException("Download failed"));

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseArtifactService).downloadReleaseZipToPvc("v1.0.0");
        verify(releaseArtifactService).downloadReleaseZipToPvc("v2.0.0");
    }

    @Test
    public void testUpdateVulnerabilityImpact_UpdatesExistingFields() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-UPDATE";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(6.0, "Updated impact");

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(3.0);
        existingVuln.setImpactDescription("Old impact");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));
        when(vulnerabilityRepository.save(any(Vulnerability.class))).thenAnswer(inv -> inv.getArgument(0));
        when(mapper.toDTO(any(Vulnerability.class), any()))
                .thenReturn(new VulnerabilityResponse(
                        cveId, VulnerabilitySeverity.MEDIUM, 5.0, "Desc", null, 6.0, "Updated impact"));

        vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        assertEquals(6.0, savedVuln.getImpactScore());
        assertEquals("Updated impact", savedVuln.getImpactDescription());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_WithEmptyString() {
        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId("");
        assertTrue(result.isEmpty());
        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void testDeleteVulnerabilityImpact_ClearsExistingImpact() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-CLEAR";
        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(9.5);
        existingVuln.setImpactDescription("Critical impact");
        existingVuln.setSeverity(VulnerabilitySeverity.CRITICAL);
        existingVuln.setCvssScore(9.8);

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));

        vulnerabilityService.deleteVulnerabilityImpact(cveId);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        Assertions.assertNull(savedVuln.getImpactScore());
        Assertions.assertNull(savedVuln.getImpactDescription());
        assertEquals(VulnerabilitySeverity.CRITICAL, savedVuln.getSeverity());
        assertEquals(9.8, savedVuln.getCvssScore());
    }

    @Test
    public void testGetAllVulnerabilities_WithMixedSeverities() {
        Vulnerability low = new Vulnerability();
        low.setCveId("CVE-LOW");
        low.setSeverity(VulnerabilitySeverity.LOW);

        Vulnerability medium = new Vulnerability();
        medium.setCveId("CVE-MEDIUM");
        medium.setSeverity(VulnerabilitySeverity.MEDIUM);

        Vulnerability high = new Vulnerability();
        high.setCveId("CVE-HIGH");
        high.setSeverity(VulnerabilitySeverity.HIGH);

        Vulnerability critical = new Vulnerability();
        critical.setCveId("CVE-CRITICAL");
        critical.setSeverity(VulnerabilitySeverity.CRITICAL);

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(low, medium, high, critical));
        when(mapper.toDTO(any(Vulnerability.class), any())).thenAnswer(inv -> {
            Vulnerability v = inv.getArgument(0);
            return new VulnerabilityResponse(v.getCveId(), v.getSeverity(), 0.0, "Desc", null, null, null);
        });

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertEquals(4, result.size());
    }

    @Test
    public void testUnzipAndFilter_WithValidZip_ExtractsFiles(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry entry = new ZipEntry("pom.xml");
            zos.putNextEntry(entry);
            zos.write("<project></project>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertTrue(Files.exists(extractDir.resolve("pom.xml")));
    }

    @Test
    public void testUnzipAndFilter_SkipsJavaFiles(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry javaEntry = new ZipEntry("Main.java");
            zos.putNextEntry(javaEntry);
            zos.write("public class Main {}".getBytes());
            zos.closeEntry();

            ZipEntry pomEntry = new ZipEntry("pom.xml");
            zos.putNextEntry(pomEntry);
            zos.write("<project></project>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(extractDir.resolve("Main.java")));
        assertTrue(Files.exists(extractDir.resolve("pom.xml")));
    }

    @Test
    public void testUnzipAndFilter_SkipsTestFolders(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry testEntry = new ZipEntry("src/test/resources/test.xml");
            zos.putNextEntry(testEntry);
            zos.write("<test></test>".getBytes());
            zos.closeEntry();

            ZipEntry mainEntry = new ZipEntry("src/main/resources/config.xml");
            zos.putNextEntry(mainEntry);
            zos.write("<config></config>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(extractDir.resolve("src/test/resources/test.xml")));
        assertTrue(Files.exists(extractDir.resolve("src/main/resources/config.xml")));
    }

    @Test
    public void testUnzipAndFilter_PreventsZipSlip(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("malicious.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry maliciousEntry = new ZipEntry("../../../etc/passwd");
            zos.putNextEntry(maliciousEntry);
            zos.write("malicious content".getBytes());
            zos.closeEntry();

            ZipEntry normalEntry = new ZipEntry("normal.xml");
            zos.putNextEntry(normalEntry);
            zos.write("<normal></normal>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(tempDir.resolve("etc/passwd")));
        assertTrue(Files.exists(extractDir.resolve("normal.xml")));
    }

    @Test
    public void testUnzipAndFilter_CreatesDirectories(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry dirEntry = new ZipEntry("nested/dir/");
            zos.putNextEntry(dirEntry);
            zos.closeEntry();

            ZipEntry fileEntry = new ZipEntry("nested/dir/file.xml");
            zos.putNextEntry(fileEntry);
            zos.write("<file></file>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertTrue(Files.exists(extractDir.resolve("nested/dir")));
        assertTrue(Files.isDirectory(extractDir.resolve("nested/dir")));
        assertTrue(Files.exists(extractDir.resolve("nested/dir/file.xml")));
    }

    @Test
    public void testUnzipAndFilter_SkipsImageFiles(@TempDir Path tempDir) throws Exception {
        Path zipFile = tempDir.resolve("test.zip");
        Path extractDir = tempDir.resolve("extracted");

        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile.toFile()))) {
            ZipEntry pngEntry = new ZipEntry("image.png");
            zos.putNextEntry(pngEntry);
            zos.write(new byte[] {(byte) 0x89, 0x50, 0x4E, 0x47});
            zos.closeEntry();

            ZipEntry jpgEntry = new ZipEntry("photo.jpg");
            zos.putNextEntry(jpgEntry);
            zos.write(new byte[] {(byte) 0xFF, (byte) 0xD8, (byte) 0xFF});
            zos.closeEntry();

            ZipEntry xmlEntry = new ZipEntry("config.xml");
            zos.putNextEntry(xmlEntry);
            zos.write("<config></config>".getBytes());
            zos.closeEntry();
        }

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                tempDir.toString(),
                tempDir.toString());

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("unzipAndFilter", Path.class, Path.class);
        method.setAccessible(true);
        method.invoke(testService, zipFile, extractDir);

        assertFalse(Files.exists(extractDir.resolve("image.png")));
        assertFalse(Files.exists(extractDir.resolve("photo.jpg")));
        assertTrue(Files.exists(extractDir.resolve("config.xml")));
    }

    @Test
    public void testShouldSkipExtension_VariousExtensions() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipExtension", String.class);
        method.setAccessible(true);

        assertTrue((Boolean) method.invoke(testService, "Test.java"));
        assertTrue((Boolean) method.invoke(testService, "script.py"));
        assertTrue((Boolean) method.invoke(testService, "image.png"));
        assertTrue((Boolean) method.invoke(testService, "document.pdf"));
        assertTrue((Boolean) method.invoke(testService, "style.css"));
        assertFalse((Boolean) method.invoke(testService, "pom.xml"));
        assertFalse((Boolean) method.invoke(testService, "build.gradle"));
        assertFalse((Boolean) method.invoke(testService, "package.json"));
    }

    @Test
    public void testShouldSkipFolder_VariousFolders() throws Exception {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp",
                "/tmp");

        java.lang.reflect.Method method =
                VulnerabilityService.class.getDeclaredMethod("shouldSkipFolder", String.class);
        method.setAccessible(true);

        assertTrue((Boolean) method.invoke(testService, "src/test/java/Test.xml"));
        assertTrue((Boolean) method.invoke(testService, "node_modules/package/index.js"));
        assertTrue((Boolean) method.invoke(testService, ".git/config"));
        assertFalse((Boolean) method.invoke(testService, "src/main/resources/config.xml"));
        assertFalse((Boolean) method.invoke(testService, "lib/dependency.jar"));
    }
}
