package org.frankframework.insights.vulnerability;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import io.github.jeremylong.openvulnerability.client.nvd.CvssV2;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV2Data;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3Data;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV4;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV4Data;
import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.properties.NVDProperties;
import org.frankframework.insights.common.properties.OSSProperties;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;

@ExtendWith(MockitoExtension.class)
public class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;

    @Mock
    private ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    @Mock
    private ReleaseRepository releaseRepository;

    @Mock
    private ReleaseArtifactService releaseArtifactService;

    @Mock
    private OSSProperties ossProperties;

    @Mock
    private NVDProperties nvdProperties;

    private VulnerabilityService vulnerabilityService;

    @Captor
    private ArgumentCaptor<org.frankframework.insights.vulnerability.Vulnerability> vulnerabilityCaptor;

    @Captor
    private ArgumentCaptor<ReleaseVulnerability> releaseVulnerabilityCaptor;

    private MockedStatic<Files> mockedFiles;

    @TempDir
    private Path tempDir;

    @BeforeEach
    public void setUp() {
        mockedFiles = Mockito.mockStatic(Files.class);
        when(nvdProperties.getDelay()).thenReturn(400);

        vulnerabilityService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                ossProperties,
                nvdProperties);
    }

    @AfterEach
    public void tearDown() {
        mockedFiles.close();
    }


    @Test
	public void executeVulnerabilityScanForAllReleases_shouldDoNothingWhenNoReleasesExist() throws IOException {
        when(releaseRepository.findAll()).thenReturn(Collections.emptyList());

        vulnerabilityService.executeVulnerabilityScanForAllReleases();

        verify(releaseRepository).findAll();
        verify(releaseArtifactService, never()).prepareReleaseArtifacts(any());
    }

    @Test
	public void executeVulnerabilityScanForAllReleases_shouldSkipScanForInvalidDirectory() throws IOException {
        Release release = new Release();
        release.setName("test-release");
        when(releaseRepository.findAll()).thenReturn(List.of(release));
        when(releaseArtifactService.prepareReleaseArtifacts(release))
                .thenReturn(tempDir.resolve("non-existent"));
        mockedFiles.when(() -> Files.isDirectory(any(Path.class))).thenReturn(false);

        vulnerabilityService.executeVulnerabilityScanForAllReleases();

        verify(releaseArtifactService).prepareReleaseArtifacts(release);
    }



    @Test
	public void determineCvssScore_shouldPreferV4_thenV3_thenV2() throws Exception {
        Vulnerability vuln = new Vulnerability();
        Method method = VulnerabilityService.class.getDeclaredMethod("determineCvssScore", Vulnerability.class);
        method.setAccessible(true);

        CvssV4 cvssV4 = mock(CvssV4.class);
        CvssV4Data cvssV4Data = mock(CvssV4Data.class);
        when(cvssV4.getCvssData()).thenReturn(cvssV4Data);
        when(cvssV4Data.getBaseScore()).thenReturn(9.5);
        vuln.setCvssV4(cvssV4);

        CvssV3 cvssV3 = mock(CvssV3.class);
        CvssV3Data cvssV3Data = mock(CvssV3Data.class);
        when(cvssV3.getCvssData()).thenReturn(cvssV3Data);
        when(cvssV3Data.getBaseScore()).thenReturn(8.5);
        vuln.setCvssV3(cvssV3);

        CvssV2 cvssV2 = mock(CvssV2.class);
        CvssV2Data cvssV2Data = mock(CvssV2Data.class);
        when(cvssV2.getCvssData()).thenReturn(cvssV2Data);
        when(cvssV2Data.getBaseScore()).thenReturn(7.5);
        vuln.setCvssV2(cvssV2);

        assertEquals(9.5, (Double) method.invoke(vulnerabilityService, vuln));
        vuln.setCvssV4(null);
        assertEquals(8.5, (Double) method.invoke(vulnerabilityService, vuln));
        vuln.setCvssV3(null);
        assertEquals(7.5, (Double) method.invoke(vulnerabilityService, vuln));
    }

    @Test
	public void determineCvssScore_shouldReturnNegativeOneWhenNoScoreAvailable() throws Exception {
        Method method = VulnerabilityService.class.getDeclaredMethod("determineCvssScore", Vulnerability.class);
        method.setAccessible(true);

        assertEquals(-1.0, (Double) method.invoke(vulnerabilityService, new Vulnerability()));
        assertEquals(-1.0, (Double) method.invoke(vulnerabilityService, (Object) null));
    }

    @Test
    public void createAndSaveNewVulnerability_shouldMapSeverityCorrectlyForBoundaryScores() throws Exception {
        Vulnerability vulnZero = new Vulnerability();
        vulnZero.setName("CVE-ZERO");
        CvssV3 cvssV3Zero = mock(CvssV3.class);
        CvssV3Data cvssV3DataZero = mock(CvssV3Data.class);
        when(cvssV3Zero.getCvssData()).thenReturn(cvssV3DataZero);
        when(cvssV3DataZero.getBaseScore()).thenReturn(0.0);
        vulnZero.setCvssV3(cvssV3Zero);

        Vulnerability vulnMedium = new Vulnerability();
        vulnMedium.setName("CVE-MEDIUM");
        CvssV3 cvssV3Medium = mock(CvssV3.class);
        CvssV3Data cvssV3DataMedium = mock(CvssV3Data.class);
        when(cvssV3Medium.getCvssData()).thenReturn(cvssV3DataMedium);
        when(cvssV3DataMedium.getBaseScore()).thenReturn(6.9);
        vulnMedium.setCvssV3(cvssV3Medium);

        Vulnerability vulnHigh = new Vulnerability();
        vulnHigh.setName("CVE-HIGH");
        CvssV3 cvssV3High = mock(CvssV3.class);
        CvssV3Data cvssV3DataHigh = mock(CvssV3Data.class);
        when(cvssV3High.getCvssData()).thenReturn(cvssV3DataHigh);
        when(cvssV3DataHigh.getBaseScore()).thenReturn(7.0);
        vulnHigh.setCvssV3(cvssV3High);

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture()))
                .thenAnswer(inv -> inv.getArgument(0));

        Method method = VulnerabilityService.class.getDeclaredMethod(
                "createAndSaveNewVulnerability", Vulnerability.class);
        method.setAccessible(true);

        method.invoke(vulnerabilityService, vulnZero);
        assertEquals(VulnerabilitySeverity.NONE, vulnerabilityCaptor.getValue().getSeverity());

        method.invoke(vulnerabilityService, vulnMedium);
        assertEquals(VulnerabilitySeverity.MEDIUM, vulnerabilityCaptor.getValue().getSeverity());

        method.invoke(vulnerabilityService, vulnHigh);
        assertEquals(VulnerabilitySeverity.HIGH, vulnerabilityCaptor.getValue().getSeverity());
    }

    @Test
    public void createAndSaveNewVulnerability_shouldLimitCweEntries() throws Exception {
        Vulnerability scannedVuln = new Vulnerability();
        scannedVuln.setName("CVE-2023-CWE-LIMIT");

        Set<String> cwes = IntStream.range(0, 300)
                .mapToObj(i -> "CWE-" + i)
                .collect(Collectors.toSet());

        cwes.forEach(cwe -> scannedVuln.getCwes().getEntries().add(cwe));

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture()))
                .thenAnswer(inv -> inv.getArgument(0));

        Method method = VulnerabilityService.class.getDeclaredMethod(
                "createAndSaveNewVulnerability", Vulnerability.class);
        method.setAccessible(true);
        method.invoke(vulnerabilityService, scannedVuln);

        org.frankframework.insights.vulnerability.Vulnerability captured = vulnerabilityCaptor.getValue();
        assertNotNull(captured.getCwes());
        assertTrue(captured.getCwes().size() <= 255);
    }

    @Test
    public void createAndSaveNewVulnerability_shouldHandleNullCwes() throws Exception {
        Vulnerability scannedVuln = mock(Vulnerability.class);
        when(scannedVuln.getName()).thenReturn("CVE-2023-NULL-CWE");
        when(scannedVuln.getCwes()).thenReturn(null);

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture()))
                .thenAnswer(inv -> inv.getArgument(0));

        Method method = VulnerabilityService.class.getDeclaredMethod(
                "createAndSaveNewVulnerability", Vulnerability.class);
        method.setAccessible(true);
        method.invoke(vulnerabilityService, scannedVuln);

        org.frankframework.insights.vulnerability.Vulnerability captured = vulnerabilityCaptor.getValue();
        assertNull(captured.getCwes());
    }

    @Test
    public void createOwaspSettings_shouldConfigureCredentialsWhenPresent() throws Exception {
        OSSProperties testOssProps = mock(OSSProperties.class);
        NVDProperties testNvdProps = mock(NVDProperties.class);

        when(testOssProps.getUsername()).thenReturn("testuser");
        when(testOssProps.getToken()).thenReturn("testtoken");
        when(testNvdProps.getKey()).thenReturn("testkey");
        when(testNvdProps.getDelay()).thenReturn(500);

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                testOssProps,
                testNvdProps);

        Method method = VulnerabilityService.class.getDeclaredMethod("createOwaspSettings");
        method.setAccessible(true);
        org.owasp.dependencycheck.utils.Settings settings =
                (org.owasp.dependencycheck.utils.Settings) method.invoke(testService);

        assertEquals(
                "testuser",
                settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_USER));
        assertEquals(
                "testtoken",
                settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD));
        assertEquals(
                "testkey",
                settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.NVD_API_KEY));
        assertEquals(500, settings.getInt(org.owasp.dependencycheck.utils.Settings.KEYS.NVD_API_DELAY));
    }

    @Test
    public void createOwaspSettings_shouldNotConfigureCredentialsWhenAbsent() throws Exception {
        OSSProperties testOssProps = mock(OSSProperties.class);
        NVDProperties testNvdProps = mock(NVDProperties.class);

        when(testOssProps.getUsername()).thenReturn(" ");
        when(testOssProps.getToken()).thenReturn(null);
        when(testNvdProps.getKey()).thenReturn("");
        when(testNvdProps.getDelay()).thenReturn(400);

        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                testOssProps,
                testNvdProps);

        Method method = VulnerabilityService.class.getDeclaredMethod("createOwaspSettings");
        method.setAccessible(true);
        org.owasp.dependencycheck.utils.Settings settings =
                (org.owasp.dependencycheck.utils.Settings) method.invoke(testService);

        assertNull(settings.getString(
                org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_USER, null));
        assertNull(settings.getString(
                org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD, null));
        assertNull(settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.NVD_API_KEY, null));
    }

    @Test
    public void mapSeverityFromString_shouldHandleNullAndBlankValues() throws Exception {
        Method method = VulnerabilityService.class.getDeclaredMethod("mapSeverityFromString", String.class);
        method.setAccessible(true);

        assertEquals(VulnerabilitySeverity.UNKNOWN, method.invoke(vulnerabilityService, (Object) null));
        assertEquals(VulnerabilitySeverity.UNKNOWN, method.invoke(vulnerabilityService, ""));
        assertEquals(VulnerabilitySeverity.UNKNOWN, method.invoke(vulnerabilityService, "   "));
    }

    @Test
    public void mapSeverityFromString_shouldHandleCaseInsensitiveMatching() throws Exception {
        Method method = VulnerabilityService.class.getDeclaredMethod("mapSeverityFromString", String.class);
        method.setAccessible(true);

        assertEquals(VulnerabilitySeverity.CRITICAL, method.invoke(vulnerabilityService, "critical"));
        assertEquals(VulnerabilitySeverity.CRITICAL, method.invoke(vulnerabilityService, "CRITICAL"));
        assertEquals(VulnerabilitySeverity.HIGH, method.invoke(vulnerabilityService, "High"));
        assertEquals(VulnerabilitySeverity.MEDIUM, method.invoke(vulnerabilityService, "MeDiUm"));
    }

    @Test
    public void mapSeverityFromString_shouldReturnUnknownForInvalidSeverity() throws Exception {
        Method method = VulnerabilityService.class.getDeclaredMethod("mapSeverityFromString", String.class);
        method.setAccessible(true);

        assertEquals(VulnerabilitySeverity.UNKNOWN, method.invoke(vulnerabilityService, "INVALID"));
        assertEquals(VulnerabilitySeverity.UNKNOWN, method.invoke(vulnerabilityService, "SuperCritical"));
    }

    @Test
    public void scanDirectory_shouldSkipScanForNullDirectory() throws Exception {
        Release release = new Release();
        release.setName("null-dir-release");

        Method scanDirectoryMethod = VulnerabilityService.class.getDeclaredMethod(
                "scanDirectory", Release.class, Path.class);
        scanDirectoryMethod.setAccessible(true);
        scanDirectoryMethod.invoke(vulnerabilityService, release, null);

        verify(releaseVulnerabilityRepository, never()).deleteAllByRelease(any());
    }

    @Test
    public void countVulnerabilities_shouldHandleEmptyDependenciesArray() throws Exception {
        Method method = VulnerabilityService.class.getDeclaredMethod(
                "countVulnerabilities", Dependency[].class);
        method.setAccessible(true);

        assertEquals(0, (int) method.invoke(vulnerabilityService, (Object) new Dependency[0]));
    }

    @Test
    public void countVulnerabilities_shouldHandleNullArray() throws Exception {
        Method method = VulnerabilityService.class.getDeclaredMethod(
                "countVulnerabilities", Dependency[].class);
        method.setAccessible(true);

        assertEquals(0, (int) method.invoke(vulnerabilityService, (Object) null));
    }

    @Test
	public void countVulnerabilities_shouldCountCorrectly() throws Exception {
        Method method = VulnerabilityService.class.getDeclaredMethod(
                "countVulnerabilities", Dependency[].class);
        method.setAccessible(true);

        Vulnerability vuln1 = new Vulnerability();
        vuln1.setName("CVE-1");
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setName("CVE-2");
        Vulnerability vuln3 = new Vulnerability();
        vuln3.setName("CVE-3");

        Dependency dep1 = new Dependency();
        dep1.addVulnerability(vuln1);
        dep1.addVulnerability(vuln2);

        Dependency dep2 = new Dependency();
        dep2.addVulnerability(vuln3);

        assertEquals(3, (int) method.invoke(vulnerabilityService, (Object) new Dependency[] {dep1, dep2}));
    }

    @Test
    public void createAndSaveNewVulnerability_shouldUseFallbackSeverityWhenScoreIsNegative() throws Exception {
        Vulnerability vuln = new Vulnerability();
        vuln.setName("CVE-NO-SCORE");
        vuln.setUnscoredSeverity("LOW");

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture()))
                .thenAnswer(inv -> inv.getArgument(0));

        Method method = VulnerabilityService.class.getDeclaredMethod(
                "createAndSaveNewVulnerability", Vulnerability.class);
        method.setAccessible(true);
        method.invoke(vulnerabilityService, vuln);

        assertEquals(VulnerabilitySeverity.LOW, vulnerabilityCaptor.getValue().getSeverity());
        assertEquals(-1.0, vulnerabilityCaptor.getValue().getCvssScore());
    }

}
