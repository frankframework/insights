package org.frankframework.insights.vulnerability;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anySet;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockConstruction;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.common.mapper.MappingException;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedConstruction;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;

    @Mock
    private ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    @Mock
    private ReleaseRepository releaseRepository;

    @Mock
    private ReleaseArtifactService releaseArtifactService;

    @Mock
    private Mapper mapper;

    @InjectMocks
    private VulnerabilityService vulnerabilityService;

    @Captor
    private ArgumentCaptor<Set<Vulnerability>> vulnerabilitiesCaptor;

    @Captor
    private ArgumentCaptor<List<ReleaseVulnerability>> linksCaptor;

    @TempDir
    private Path tempDir;

    private Release release;

    @BeforeEach
    public void setUp() {
        ReflectionTestUtils.setField(vulnerabilityService, "trivyExecutable", "trivy");

        release = new Release();
        release.setId("release-1");
        release.setName("Test Release");
        release.setTagName("v1.0.0");
    }

    @AfterEach
    public void tearDown() {
        Thread.interrupted();
    }

    @Test
    public void testScanAll_NoReleases() throws IOException {
        when(releaseRepository.findAll()).thenReturn(Collections.emptyList());

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseRepository).findAll();
        verify(releaseArtifactService, never()).prepareReleaseArtifacts(any());
    }

	@Test
	public void testScanAll_ReleaseWithNoTag() throws IOException, InterruptedException {
		Release noTagRelease = new Release();
		noTagRelease.setName("No Tag");
		when(releaseRepository.findAll()).thenReturn(new java.util.ArrayList<>(List.of(noTagRelease)));

		VulnerabilityService spyService = spy(vulnerabilityService);

		spyService.scanAndSaveVulnerabilitiesForAllReleases();

		verify(releaseRepository).findAll();
		verify(spyService, never()).scanAndSaveVulnerabilitiesForSingleRelease(any());
	}

	@Test
	public void testScanAll_HandlesScanExceptionAndContinues() throws Exception {
		Release release1 = new Release();
		release1.setName("Release 1");
		release1.setTagName("v1");
		Release release2 = new Release();
		release2.setName("Release 2");
		release2.setTagName("v2");
		when(releaseRepository.findAll()).thenReturn(new java.util.ArrayList<>(List.of(release1, release2)));

		VulnerabilityService spyService = spy(vulnerabilityService);
		doThrow(new IOException("Scan failed")).when(spyService).scanAndSaveVulnerabilitiesForSingleRelease(release1);
		doReturn(0).when(spyService).scanAndSaveVulnerabilitiesForSingleRelease(release2);

		spyService.scanAndSaveVulnerabilitiesForAllReleases();

		verify(spyService, times(1)).scanAndSaveVulnerabilitiesForSingleRelease(release1);
		verify(spyService, times(1)).scanAndSaveVulnerabilitiesForSingleRelease(release2);
	}

	@Test
	public void testScanAll_HandlesInterruptedException() throws Exception {
		Release release1 = new Release();
		release1.setName("Release 1");
		release1.setTagName("v1");
		Release release2 = new Release();
		release2.setName("Release 2");
		release2.setTagName("v2");
		when(releaseRepository.findAll()).thenReturn(new java.util.ArrayList<>(List.of(release1, release2)));

		VulnerabilityService spyService = spy(vulnerabilityService);
		doThrow(new InterruptedException()).when(spyService).scanAndSaveVulnerabilitiesForSingleRelease(release1);

		spyService.scanAndSaveVulnerabilitiesForAllReleases();

		verify(spyService, times(1)).scanAndSaveVulnerabilitiesForSingleRelease(release1);
		verify(spyService, never()).scanAndSaveVulnerabilitiesForSingleRelease(release2);
		assertTrue(Thread.currentThread().isInterrupted());
	}


    /**
     * Mocks the construction of ProcessBuilder to return a mock Process.
     * @param exitCode The exit code the mock process should return.
     * @param output The string output the process should return via its InputStream.
     * @return A MockedConstruction object to be closed by the caller.
     */
    private MockedConstruction<ProcessBuilder> mockTrivyProcess(int exitCode, String output)
            throws InterruptedException {
        Process processMock = mock(Process.class);
        when(processMock.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processMock.exitValue()).thenReturn(exitCode);
        when(processMock.getInputStream()).thenAnswer(inv -> new ByteArrayInputStream(output.getBytes()));

        return mockConstruction(ProcessBuilder.class, (mock, context) -> {
            when(mock.start()).thenReturn(processMock);
        });
    }

    @Test
    public void testScanSingle_Success_FindsVulnerabilities() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = getValidReport();
        TrivyReport report = getValidReportObject();

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.findAllById(any())).thenReturn(Collections.emptyList());
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);

            assertEquals(2, links);
        }

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId(release.getId());
        verify(vulnerabilityRepository).saveAll(vulnerabilitiesCaptor.capture());
        verify(releaseVulnerabilityRepository).saveAll(linksCaptor.capture());

        assertEquals(2, vulnerabilitiesCaptor.getValue().size());
        assertEquals(2, linksCaptor.getValue().size());

        Vulnerability cve1 = vulnerabilitiesCaptor.getValue().stream()
                .filter(v -> v.getCveId().equals("CVE-2023-1234"))
                .findFirst()
                .orElse(null);
        assertNotNull(cve1);
        assertEquals("Critical Vuln | Details...", cve1.getDescription());
        assertEquals(VulnerabilitySeverity.CRITICAL, cve1.getSeverity());
        assertEquals(9.8, cve1.getCvssScore());
        assertTrue(cve1.getCwes().contains("CWE-89"));
    }

    @Test
    public void testScanSingle_Success_NoVulnerabilities() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = "{ \"Results\": [] }";
        TrivyReport report = new TrivyReport();
        report.Results = new java.util.ArrayList<>();

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
            assertEquals(0, links);
        }

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId(release.getId());
        verify(vulnerabilityRepository, never()).saveAll(any());
        verify(releaseVulnerabilityRepository, never()).saveAll(any());
    }

    @Test
    public void testScanSingle_Success_UpdatesExistingVulnerability() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = getValidReport();
        TrivyReport report = getValidReportObject();

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId("CVE-2023-1234");
        existingVuln.setSeverity(VulnerabilitySeverity.MEDIUM);
        existingVuln.setDescription("Old Description");
        existingVuln.setCvssScore(5.0);

        when(vulnerabilityRepository.findAllById(any(Set.class))).thenReturn(List.of(existingVuln));
        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
        }

        verify(vulnerabilityRepository).saveAll(vulnerabilitiesCaptor.capture());
        assertEquals(2, vulnerabilitiesCaptor.getValue().size());

        Vulnerability updatedVuln = vulnerabilitiesCaptor.getValue().stream()
                .filter(v -> v.getCveId().equals("CVE-2023-1234"))
                .findFirst()
                .orElse(null);

        assertNotNull(updatedVuln);
        assertEquals("Critical Vuln | Details...", updatedVuln.getDescription());
        assertEquals(VulnerabilitySeverity.CRITICAL, updatedVuln.getSeverity());
        assertEquals(9.8, updatedVuln.getCvssScore());
    }

    @Test
    public void testScanSingle_TrivyReturnsNullResults() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = "{ \"Results\": null }";
        TrivyReport report = new TrivyReport();
        report.Results = null;

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
            assertEquals(0, links);
        }

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId(release.getId());
        verify(vulnerabilityRepository, never()).saveAll(any());
    }

    @Test
    public void testScanSingle_TrivyScanFails_NonZeroExit() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String errorOutput = "Error: Failed to scan";

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(1, errorOutput)) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));

            assertEquals(errorOutput, e.getMessage());
        }

        verify(mapper, never()).fromJson(any(), any());
    }

    @Test
    public void testScanSingle_TrivyScanTimesOut() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        Process processMock = mock(Process.class);
        when(processMock.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(false); // Simulate timeout
        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream("".getBytes()));

        try (MockedConstruction<ProcessBuilder> ignored = mockConstruction(ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processMock))) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertTrue(e.getMessage().contains("Trivy scan timed out"));
        }
    }

    @Test
    public void testScanSingle_JsonParsingFails() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String invalidJson = "this is not json";

        doThrow(new MappingException("Failed to parse", null)).when(mapper).fromJson(invalidJson, TrivyReport.class);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, invalidJson)) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertTrue(e.getMessage().contains("Failed to parse Trivy JSON output"));
        }
    }

    @Test
    public void testScanSingle_RetryOnDatabaseLock_Succeeds() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String lockError = "database is locked";
        String trivyJson = getValidReport();
        TrivyReport report = getValidReportObject();

        Process processMock = mock(Process.class);
        when(processMock.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processMock.exitValue()).thenReturn(1, 0);
        when(processMock.getInputStream())
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()))
                .thenAnswer(inv -> new ByteArrayInputStream(trivyJson.getBytes()));

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));

        try (MockedConstruction<ProcessBuilder> mockedBuilder =
                mockConstruction(ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processMock))) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
            assertEquals(2, links);

            assertEquals(2, mockedBuilder.constructed().size());
            verify(mockedBuilder.constructed().get(0), times(1)).start();
            verify(mockedBuilder.constructed().get(1), times(1)).start();
            verify(processMock, times(2)).exitValue();
        }
    }

    @Test
    public void testScanSingle_RetryOnDatabaseLock_FailsAllAttempts() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String lockError = "database is locked";

        Process processFail = mock(Process.class);
        when(processFail.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processFail.exitValue()).thenReturn(1);
        when(processFail.getInputStream())
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()))
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()))
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()));

        try (MockedConstruction<ProcessBuilder> mockedBuilder = mockConstruction(
                ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processFail))) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertTrue(e.getMessage().contains("Trivy scan failed after 3 attempts"));

            assertEquals(3, mockedBuilder.constructed().size());
            mockedBuilder.constructed().forEach(mock -> {
                try {
                    verify(mock, times(1)).start();
                } catch (IOException ex) {
                    throw new RuntimeException(ex);
                }
            });
        }
    }

    @Test
    public void testScanSingle_NonLockError_FailsImmediately() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String otherError = "some other error";

        Process processFail = mock(Process.class);
        when(processFail.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processFail.exitValue()).thenReturn(1);
        when(processFail.getInputStream()).thenAnswer(inv -> new ByteArrayInputStream(otherError.getBytes()));

        try (MockedConstruction<ProcessBuilder> mockedBuilder =
                mockConstruction(ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processFail))) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertEquals(otherError, e.getMessage());

            assertEquals(1, mockedBuilder.constructed().size());
            verify(mockedBuilder.constructed().getFirst(), times(1)).start();
        }
    }

    @Test
    public void testGetVulnerabilities_Success() {
        String releaseId = "release-123";
        Vulnerability vuln = new Vulnerability();
        vuln.setCveId("CVE-2023-0001");
        ReleaseVulnerability link = new ReleaseVulnerability(release, vuln);
        VulnerabilityResponse response =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc", null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link));
        when(mapper.toDTO(vuln, VulnerabilityResponse.class)).thenReturn(response);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.contains(response));
    }

    @Test
    public void testGetVulnerabilities_NoLinks() {
        String releaseId = "release-456";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetVulnerabilities_NullOrBlankId() {
        Set<VulnerabilityResponse> resultNull = vulnerabilityService.getVulnerabilitiesByReleaseId(null);
        assertTrue(resultNull.isEmpty());

        Set<VulnerabilityResponse> resultBlank = vulnerabilityService.getVulnerabilitiesByReleaseId("  ");
        assertTrue(resultBlank.isEmpty());

        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void testGetVulnerabilities_RepoThrowsException() {
        String releaseId = "release-ex";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testMapping_ScorePriority_And_ExistingScore() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = getComplexScoreReport();
        TrivyReport report = getComplexScoreReportObject();

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId("CVE-EXISTING");
        existingVuln.setCvssScore(5.5);

        when(vulnerabilityRepository.findAllById(anySet())).thenReturn(List.of(existingVuln));

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
        }

        verify(vulnerabilityRepository).saveAll(vulnerabilitiesCaptor.capture());
        Map<String, Vulnerability> savedVulns =
                vulnerabilitiesCaptor.getValue().stream().collect(Collectors.toMap(Vulnerability::getCveId, v -> v));

        assertEquals(5, savedVulns.size());

        assertEquals(9.8, savedVulns.get("CVE-NVD-V3").getCvssScore());
        assertEquals(9.1, savedVulns.get("CVE-RH-V3").getCvssScore());
        assertEquals(7.5, savedVulns.get("CVE-V2-ONLY").getCvssScore());
        assertEquals(5.5, savedVulns.get("CVE-NO-SCORE").getCvssScore());
        assertEquals(5.5, savedVulns.get("CVE-EXISTING").getCvssScore());
    }

    private String getValidReport() {
        return "{\"Results\":[{\"Target\":\"pom.xml\",\"Vulnerabilities\":[{\"VulnerabilityID\":\"CVE-2023-1234\",\"Title\":\"Critical Vuln\",\"Description\":\"Details...\",\"Severity\":\"CRITICAL\",\"CweIDs\":[\"CWE-89\"],\"CVSS\":{\"nvd\":{\"V3Score\":9.8}}},{\"VulnerabilityID\":\"CVE-2023-5678\",\"Title\":\"High Vuln\",\"Description\":\"Details...\",\"Severity\":\"HIGH\",\"CVSS\":{\"redhat\":{\"V2Score\":7.5}}}]}]}";
    }

    private TrivyReport getValidReportObject() {
        TrivyReport report = new TrivyReport();

        TrivyCvssScore cve1Score = new TrivyCvssScore(null, null, 9.8, null);
        TrivyVulnerability cve1 = new TrivyVulnerability(
                "CVE-2023-1234",
                "Critical Vuln",
                "Details...",
                "CRITICAL",
                List.of("CWE-89"),
                Map.of("nvd", cve1Score));

        TrivyCvssScore cve2Score = new TrivyCvssScore(7.5, null, null, null);
        TrivyVulnerability cve2 = new TrivyVulnerability(
                "CVE-2023-5678", "High Vuln", "Details...", "HIGH", null, Map.of("redhat", cve2Score));

        TrivyResult result = new TrivyResult("pom.xml", null, null, List.of(cve1, cve2));

        report.Results = List.of(result);
        return report;
    }

    /**
     * Provides a complex JSON report for testing CVSS score selection.
     * THIS MUST BE A SINGLE LINE.
     */
    private String getComplexScoreReport() {
        return "{\"Results\":[{\"Vulnerabilities\":[{\"VulnerabilityID\":\"CVE-NVD-V3\",\"Severity\":\"CRITICAL\",\"CVSS\":{\"nvd\":{\"V3Score\":9.8},\"redhat\":{\"V3Score\":9.1}}},{\"VulnerabilityID\":\"CVE-RH-V3\",\"Severity\":\"CRITICAL\",\"CVSS\":{\"redhat\":{\"V3Score\":9.1},\"other\":{\"V2Score\":7.5}}},{\"VulnerabilityID\":\"CVE-V2-ONLY\",\"Severity\":\"HIGH\",\"CVSS\":{\"other\":{\"V2Score\":7.5}}},{\"VulnerabilityID\":\"CVE-NO-SCORE\",\"Severity\":\"MEDIUM\",\"CVSS\":{}},{\"VulnerabilityID\":\"CVE-EXISTING\",\"Severity\":\"MEDIUM\",\"CVSS\":{}}]}]}";
    }

    private TrivyReport getComplexScoreReportObject() {
        TrivyReport report = new TrivyReport();

        TrivyVulnerability v1 = new TrivyVulnerability(
                "CVE-NVD-V3",
                null,
                null,
                "CRITICAL",
                null,
                Map.of(
                        "nvd",
                        new TrivyCvssScore(null, null, 9.8, null),
                        "redhat",
                        new TrivyCvssScore(null, null, 9.1, null)));
        TrivyVulnerability v2 = new TrivyVulnerability(
                "CVE-RH-V3",
                null,
                null,
                "CRITICAL",
                null,
                Map.of(
                        "redhat",
                        new TrivyCvssScore(null, null, 9.1, null),
                        "other",
                        new TrivyCvssScore(7.5, null, null, null)));
        TrivyVulnerability v3 = new TrivyVulnerability(
                "CVE-V2-ONLY", null, null, "HIGH", null, Map.of("other", new TrivyCvssScore(7.5, null, null, null)));
        TrivyVulnerability v4 =
                new TrivyVulnerability("CVE-NO-SCORE", null, null, "MEDIUM", null, Collections.emptyMap());
        TrivyVulnerability v5 =
                new TrivyVulnerability("CVE-EXISTING", null, null, "MEDIUM", null, Collections.emptyMap());

        TrivyResult result = new TrivyResult(null, null, null, List.of(v1, v2, v3, v4, v5));

        report.Results = List.of(result);
        return report;
    }
}
