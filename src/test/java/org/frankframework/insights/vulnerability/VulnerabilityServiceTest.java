package org.frankframework.insights.vulnerability;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockConstruction;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import io.github.jeremylong.openvulnerability.client.nvd.CvssV2;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV2Data;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV3Data;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV4;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV4Data;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.common.properties.NVDProperties;
import org.frankframework.insights.common.properties.OSSProperties;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;
import org.owasp.dependencycheck.utils.Settings;

@ExtendWith(MockitoExtension.class)
public class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;

    @Mock
    private ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    @Mock
    private ReleaseRepository releaseRepository;

    @Mock
    private ReleaseArtifactService releaseArtifactService;

    @Mock
    private Mapper mapper;

    @Mock
    private OSSProperties ossProperties;

    @Mock
    private NVDProperties nvdProperties;

    private VulnerabilityService vulnerabilityService;

    @Captor
    private ArgumentCaptor<org.frankframework.insights.vulnerability.Vulnerability> vulnerabilityCaptor;

    @TempDir
    private Path tempDir;

    @BeforeEach
    public void setUp() {
        when(nvdProperties.getDelay()).thenReturn(400);

        vulnerabilityService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                ossProperties,
                nvdProperties,
                tempDir.toString());
    }

    @Test
    public void executeVulnerabilityScan_shouldNotCleanDirectory_whenDatabaseIsHealthy() {
        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class)) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles.when(() -> Files.list(tempDir)).thenReturn(Stream.empty());

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            verify(releaseRepository).findAll();
            assertEquals(1, mockedEngine.constructed().size());

            mockedFiles.verify(() -> Files.walk(any()), never());
        }
    }

    @Test
    public void executeVulnerabilityScan_shouldCleanH2DatabaseFiles_whenDatabaseIsCorrupt() {
        Path h2Database = tempDir.resolve("dependency-check.mv.db");
        Path h2TraceFile = tempDir.resolve("dependency-check.trace.db");
        Path h2LockFile = tempDir.resolve("dependency-check.lock.db");
        Path cacheDir = tempDir.resolve("cache");
        Path otherFile = tempDir.resolve("readme.txt");

        class JdbcSQLException extends RuntimeException {
            public JdbcSQLException(String message) {
                super(message);
            }
        }

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class, (mock, context) -> {
                    throw new JdbcSQLException("Database file is corrupt");
                })) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles
                    .when(() -> Files.list(tempDir))
                    .thenReturn(Stream.of(h2Database, h2TraceFile, h2LockFile, cacheDir, otherFile))
                    .thenReturn(Stream.of(h2Database, h2TraceFile, h2LockFile, cacheDir, otherFile));

            mockedFiles.when(() -> Files.isDirectory(cacheDir)).thenReturn(true);
            mockedFiles.when(() -> Files.isDirectory(h2Database)).thenReturn(false);
            mockedFiles.when(() -> Files.isDirectory(h2TraceFile)).thenReturn(false);
            mockedFiles.when(() -> Files.isDirectory(h2LockFile)).thenReturn(false);
            mockedFiles.when(() -> Files.isDirectory(otherFile)).thenReturn(false);

            mockedFiles.when(() -> Files.delete(any())).thenAnswer(invocation -> null);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(h2Database), times(1));
            mockedFiles.verify(() -> Files.delete(h2TraceFile), times(1));
            mockedFiles.verify(() -> Files.delete(h2LockFile), times(2));
            mockedFiles.verify(() -> Files.delete(cacheDir), never());
            mockedFiles.verify(() -> Files.delete(otherFile), never());
        }
    }

    @Test
    public void executeVulnerabilityScan_shouldDeleteAllH2LockFiles() {
        Path mvStoreLock = tempDir.resolve("dependency-check.mv.db.lock");
        Path dbLock = tempDir.resolve("dependency-check.lock.db");
        Path genericLock = tempDir.resolve("dependency-check.lock");
        Path nonLockFile = tempDir.resolve("dependency-check.mv.db");

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class)) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles
                    .when(() -> Files.list(tempDir))
                    .thenReturn(Stream.of(mvStoreLock, dbLock, genericLock, nonLockFile));
            mockedFiles.when(() -> Files.delete(any())).thenAnswer(invocation -> null);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(mvStoreLock), times(1));
            mockedFiles.verify(() -> Files.delete(dbLock), times(1));
            mockedFiles.verify(() -> Files.delete(genericLock), times(1));
            mockedFiles.verify(() -> Files.delete(nonLockFile), never());
        }
    }

    @Test
    public void executeVulnerabilityScan_shouldNotCleanH2Files_whenEngineFailsWithNonH2Error() {
        Exception otherException = new IllegalStateException("Some other IO issue");
        Path h2Database = tempDir.resolve("dependency-check.mv.db");

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class, (mock, context) -> {
                    throw otherException;
                })) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles.when(() -> Files.list(tempDir)).thenReturn(Stream.of(h2Database));
            mockedFiles.when(() -> Files.isDirectory(h2Database)).thenReturn(false);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(h2Database), never());
        }
    }

    @Test
    public void cleanUpOwaspLockFile_shouldHandleIOExceptionOnDelete() {
        Path lockFile = tempDir.resolve("some-file.lock");

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class)) {

            mockedFiles.when(() -> Files.isDirectory(tempDir)).thenReturn(true);
            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles.when(() -> Files.list(tempDir)).thenReturn(Stream.of(lockFile));

            mockedFiles.when(() -> Files.delete(lockFile)).thenThrow(new IOException("Permission denied"));

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(lockFile), times(1));
        }
    }

    @Test
    public void executeVulnerabilityScan_shouldDetectH2VersionMismatch() {
        class H2VersionException extends RuntimeException {
            public H2VersionException() {
                super("Unsupported database file version - please upgrade to H2 version 2.x");
            }
        }

        Path h2Database = tempDir.resolve("dependency-check.mv.db");

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class, (mock, context) -> {
                    throw new H2VersionException();
                })) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles
                    .when(() -> Files.list(tempDir))
                    .thenReturn(Stream.of(h2Database))
                    .thenReturn(Stream.of(h2Database));
            mockedFiles.when(() -> Files.isDirectory(h2Database)).thenReturn(false);
            mockedFiles.when(() -> Files.delete(any())).thenAnswer(invocation -> null);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(h2Database), times(1));
        }
    }

    @Test
    public void executeVulnerabilityScan_shouldDetectH2DiskSpaceError() {
        class DiskFullException extends RuntimeException {
            public DiskFullException() {
                super("IO Exception: No space left on device");
            }
        }

        Path h2Database = tempDir.resolve("dependency-check.mv.db");

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class, (mock, context) -> {
                    throw new DiskFullException();
                })) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles
                    .when(() -> Files.list(tempDir))
                    .thenReturn(Stream.of(h2Database))
                    .thenReturn(Stream.of(h2Database));
            mockedFiles.when(() -> Files.isDirectory(h2Database)).thenReturn(false);
            mockedFiles.when(() -> Files.delete(any())).thenAnswer(invocation -> null);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(h2Database), times(1));
        }
    }

    @Test
    public void executeVulnerabilityScan_shouldDetectH2LockTimeout() {
        class LockTimeoutException extends RuntimeException {
            public LockTimeoutException() {
                super("Timeout trying to lock table \"VULNERABILITY\"; SQL statement: SELECT * FROM VULNERABILITY");
            }
        }

        Path h2Database = tempDir.resolve("dependency-check.mv.db");

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class, (mock, context) -> {
                    throw new LockTimeoutException();
                })) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles
                    .when(() -> Files.list(tempDir))
                    .thenReturn(Stream.of(h2Database))
                    .thenReturn(Stream.of(h2Database));
            mockedFiles.when(() -> Files.isDirectory(h2Database)).thenReturn(false);
            mockedFiles.when(() -> Files.delete(any())).thenAnswer(invocation -> null);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(h2Database), times(1));
        }
    }

    @Test
    public void executeVulnerabilityScan_shouldDetectH2ChecksumMismatch() {
        class ChecksumException extends RuntimeException {
            public ChecksumException() {
                super("File corrupted while reading record: checksum mismatch");
            }
        }

        Path h2Database = tempDir.resolve("dependency-check.mv.db");

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                });
                MockedConstruction<Engine> mockedEngine = mockConstruction(Engine.class, (mock, context) -> {
                    throw new ChecksumException();
                })) {

            mockedFiles.when(() -> Files.isDirectory(any())).thenReturn(true);
            mockedFiles
                    .when(() -> Files.list(tempDir))
                    .thenReturn(Stream.of(h2Database))
                    .thenReturn(Stream.of(h2Database));
            mockedFiles.when(() -> Files.isDirectory(h2Database)).thenReturn(false);
            mockedFiles.when(() -> Files.delete(any())).thenAnswer(invocation -> null);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            mockedFiles.verify(() -> Files.delete(h2Database), times(1));
        }
    }

    @Test
    public void executeVulnerabilityScanForAllReleases_shouldDoNothingWhenNoReleasesExist() throws IOException {
        when(releaseRepository.findAll()).thenReturn(Collections.emptyList());

        vulnerabilityService.executeVulnerabilityScanForAllReleases();

        verify(releaseRepository).findAll();
        verify(releaseArtifactService, never()).prepareReleaseArtifacts(any());
    }

    @Test
    public void executeVulnerabilityScanForAllReleases_shouldSkipScanForInvalidDirectory() throws IOException {
        Release release = new Release();
        release.setName("test-release");
        Path nonExistentPath = tempDir.resolve("non-existent");

        when(releaseRepository.findAll()).thenReturn(List.of(release));
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(nonExistentPath);

        try (MockedStatic<Files> mockedFiles = Mockito.mockStatic(Files.class);
                MockedConstruction<Settings> mockedSettings = mockConstruction(Settings.class, (mock, context) -> {
                    when(mock.getDataDirectory()).thenReturn(tempDir.toFile());
                })) {

            mockedFiles.when(() -> Files.isDirectory(tempDir)).thenReturn(true);
            mockedFiles.when(() -> Files.list(tempDir)).thenReturn(Stream.empty());

            mockedFiles.when(() -> Files.isDirectory(nonExistentPath)).thenReturn(false);
            mockedFiles.when(() -> Files.isDirectory(any(Path.class))).thenReturn(true);

            vulnerabilityService.executeVulnerabilityScanForAllReleases();

            verify(releaseArtifactService).prepareReleaseArtifacts(release);
        }
    }

    @Test
    public void determineCvssScore_shouldPreferV4_thenV3_thenV2() {
        Vulnerability vuln = new Vulnerability();

        CvssV4 cvssV4 = mock(CvssV4.class);
        CvssV4Data cvssV4Data = mock(CvssV4Data.class);
        when(cvssV4.getCvssData()).thenReturn(cvssV4Data);
        when(cvssV4Data.getBaseScore()).thenReturn(9.5);
        vuln.setCvssV4(cvssV4);

        CvssV3 cvssV3 = mock(CvssV3.class);
        CvssV3Data cvssV3Data = mock(CvssV3Data.class);
        when(cvssV3.getCvssData()).thenReturn(cvssV3Data);
        when(cvssV3Data.getBaseScore()).thenReturn(8.5);
        vuln.setCvssV3(cvssV3);

        CvssV2 cvssV2 = mock(CvssV2.class);
        CvssV2Data cvssV2Data = mock(CvssV2Data.class);
        when(cvssV2.getCvssData()).thenReturn(cvssV2Data);
        when(cvssV2Data.getBaseScore()).thenReturn(7.5);
        vuln.setCvssV2(cvssV2);

        assertEquals(9.5, vulnerabilityService.determineCvssScore(vuln));
        vuln.setCvssV4(null);
        assertEquals(8.5, vulnerabilityService.determineCvssScore(vuln));
        vuln.setCvssV3(null);
        assertEquals(7.5, vulnerabilityService.determineCvssScore(vuln));
    }

    @Test
    public void determineCvssScore_shouldReturnNullWhenNoScoreAvailable() {
        assertNull(vulnerabilityService.determineCvssScore(new Vulnerability()));
        assertNull(vulnerabilityService.determineCvssScore(null));
    }

    @Test
    public void createAndSaveNewVulnerability_shouldMapSeverityCorrectlyForBoundaryScores() {
        Vulnerability vulnZero = new Vulnerability();
        vulnZero.setName("CVE-ZERO");
        CvssV3 cvssV3Zero = mock(CvssV3.class);
        CvssV3Data cvssV3DataZero = mock(CvssV3Data.class);
        when(cvssV3Zero.getCvssData()).thenReturn(cvssV3DataZero);
        when(cvssV3DataZero.getBaseScore()).thenReturn(0.0);
        vulnZero.setCvssV3(cvssV3Zero);

        Vulnerability vulnMedium = new Vulnerability();
        vulnMedium.setName("CVE-MEDIUM");
        CvssV3 cvssV3Medium = mock(CvssV3.class);
        CvssV3Data cvssV3DataMedium = mock(CvssV3Data.class);
        when(cvssV3Medium.getCvssData()).thenReturn(cvssV3DataMedium);
        when(cvssV3DataMedium.getBaseScore()).thenReturn(6.9);
        vulnMedium.setCvssV3(cvssV3Medium);

        Vulnerability vulnHigh = new Vulnerability();
        vulnHigh.setName("CVE-HIGH");
        CvssV3 cvssV3High = mock(CvssV3.class);
        CvssV3Data cvssV3DataHigh = mock(CvssV3Data.class);
        when(cvssV3High.getCvssData()).thenReturn(cvssV3DataHigh);
        when(cvssV3DataHigh.getBaseScore()).thenReturn(7.0);
        vulnHigh.setCvssV3(cvssV3High);

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture())).thenAnswer(inv -> inv.getArgument(0));

        vulnerabilityService.getOrCreateVulnerability(vulnZero);
        assertEquals(VulnerabilitySeverity.NONE, vulnerabilityCaptor.getValue().getSeverity());

        vulnerabilityService.getOrCreateVulnerability(vulnMedium);
        assertEquals(
                VulnerabilitySeverity.MEDIUM, vulnerabilityCaptor.getValue().getSeverity());

        vulnerabilityService.getOrCreateVulnerability(vulnHigh);
        assertEquals(VulnerabilitySeverity.HIGH, vulnerabilityCaptor.getValue().getSeverity());
    }

    @Test
    public void createAndSaveNewVulnerability_shouldLimitCweEntries() {
        Vulnerability scannedVuln = new Vulnerability();
        scannedVuln.setName("CVE-2023-CWE-LIMIT");

        Set<String> cwes = IntStream.range(0, 300).mapToObj(i -> "CWE-" + i).collect(Collectors.toSet());

        cwes.forEach(cwe -> scannedVuln.getCwes().getEntries().add(cwe));

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture())).thenAnswer(inv -> inv.getArgument(0));

        vulnerabilityService.getOrCreateVulnerability(scannedVuln);

        org.frankframework.insights.vulnerability.Vulnerability captured = vulnerabilityCaptor.getValue();
        assertNotNull(captured.getCwes());
        assertTrue(captured.getCwes().size() <= 255);
    }

    @Test
    public void createAndSaveNewVulnerability_shouldHandleNullCwes() {
        Vulnerability scannedVuln = mock(Vulnerability.class);
        when(scannedVuln.getName()).thenReturn("CVE-2023-NULL-CWE");
        when(scannedVuln.getCwes()).thenReturn(null);

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture())).thenAnswer(inv -> inv.getArgument(0));

        vulnerabilityService.getOrCreateVulnerability(scannedVuln);

        org.frankframework.insights.vulnerability.Vulnerability captured = vulnerabilityCaptor.getValue();
        assertNull(captured.getCwes());
    }

    @Test
    public void createOwaspSettings_shouldConfigureCredentialsWhenPresent() throws Exception {
        OSSProperties testOssProps = mock(OSSProperties.class);
        NVDProperties testNvdProps = mock(NVDProperties.class);

        when(testOssProps.getUsername()).thenReturn("testuser");
        when(testOssProps.getToken()).thenReturn("testtoken");
        when(testNvdProps.getKey()).thenReturn("testkey");
        when(testNvdProps.getDelay()).thenReturn(500);

        Settings settings = getSettings(testOssProps, testNvdProps);

        assertEquals(
                "testuser", settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_USER));
        assertEquals(
                "testtoken",
                settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD));
        assertEquals("testkey", settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.NVD_API_KEY));
        assertEquals(500, settings.getInt(org.owasp.dependencycheck.utils.Settings.KEYS.NVD_API_DELAY));
    }

    private Settings getSettings(OSSProperties testOssProps, NVDProperties testNvdProps) {
        VulnerabilityService testService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                testOssProps,
                testNvdProps,
                tempDir.toString());

        return testService.createOwaspSettings();
    }

    @Test
    public void createOwaspSettings_shouldNotConfigureCredentialsWhenAbsent() {
        OSSProperties testOssProps = mock(OSSProperties.class);
        NVDProperties testNvdProps = mock(NVDProperties.class);

        when(testOssProps.getUsername()).thenReturn(" ");
        when(testOssProps.getToken()).thenReturn(null);
        when(testNvdProps.getKey()).thenReturn("");
        when(testNvdProps.getDelay()).thenReturn(400);

        Settings settings = getSettings(testOssProps, testNvdProps);

        assertNull(settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_USER, null));
        assertNull(settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.ANALYZER_OSSINDEX_PASSWORD, null));
        assertNull(settings.getString(org.owasp.dependencycheck.utils.Settings.KEYS.NVD_API_KEY, null));
    }

    @Test
    public void mapSeverityFromString_shouldHandleNullAndBlankValues() {
        assertEquals(VulnerabilitySeverity.UNKNOWN, vulnerabilityService.mapSeverityFromString(null));
        assertEquals(VulnerabilitySeverity.UNKNOWN, vulnerabilityService.mapSeverityFromString(""));
        assertEquals(VulnerabilitySeverity.UNKNOWN, vulnerabilityService.mapSeverityFromString("   "));
    }

    @Test
    public void mapSeverityFromString_shouldHandleCaseInsensitiveMatching() {
        assertEquals(VulnerabilitySeverity.CRITICAL, vulnerabilityService.mapSeverityFromString("critical"));
        assertEquals(VulnerabilitySeverity.CRITICAL, vulnerabilityService.mapSeverityFromString("CRITICAL"));
        assertEquals(VulnerabilitySeverity.HIGH, vulnerabilityService.mapSeverityFromString("High"));
        assertEquals(VulnerabilitySeverity.MEDIUM, vulnerabilityService.mapSeverityFromString("MeDiUm"));
    }

    @Test
    public void mapSeverityFromString_shouldReturnUnknownForInvalidSeverity() {
        assertEquals(VulnerabilitySeverity.UNKNOWN, vulnerabilityService.mapSeverityFromString("INVALID"));
        assertEquals(VulnerabilitySeverity.UNKNOWN, vulnerabilityService.mapSeverityFromString("SuperCritical"));
    }

    @Test
    public void countVulnerabilities_shouldHandleEmptyDependenciesArray() {
        assertEquals(0, vulnerabilityService.countVulnerabilities(new Dependency[0]));
    }

    @Test
    public void countVulnerabilities_shouldHandleNullArray() {
        assertEquals(0, vulnerabilityService.countVulnerabilities(null));
    }

    @Test
    public void countVulnerabilities_shouldCountCorrectly() {
        Vulnerability vuln1 = new Vulnerability();
        vuln1.setName("CVE-1");
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setName("CVE-2");
        Vulnerability vuln3 = new Vulnerability();
        vuln3.setName("CVE-3");

        Dependency dep1 = new Dependency();
        dep1.addVulnerability(vuln1);
        dep1.addVulnerability(vuln2);

        Dependency dep2 = new Dependency();
        dep2.addVulnerability(vuln3);

        assertEquals(3, vulnerabilityService.countVulnerabilities(new Dependency[] {dep1, dep2}));
    }

    @Test
    public void createAndSaveNewVulnerability_shouldUseFallbackSeverityWhenScoreIsNegative() {
        Vulnerability vuln = new Vulnerability();
        vuln.setName("CVE-NO-SCORE");
        vuln.setUnscoredSeverity("LOW");

        when(vulnerabilityRepository.save(vulnerabilityCaptor.capture())).thenAnswer(inv -> inv.getArgument(0));

        vulnerabilityService.getOrCreateVulnerability(vuln);

        assertEquals(VulnerabilitySeverity.LOW, vulnerabilityCaptor.getValue().getSeverity());
        assertEquals(2.0, vulnerabilityCaptor.getValue().getCvssScore());
    }

    @Test
    public void getVulnerabilitiesByReleaseId_shouldReturnEmptySetForNullReleaseId() {
        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(null);

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void getVulnerabilitiesByReleaseId_shouldReturnEmptySetForBlankReleaseId() {
        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId("");

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());

        result = vulnerabilityService.getVulnerabilitiesByReleaseId("   ");
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void getVulnerabilitiesByReleaseId_shouldReturnEmptySetWhenNoVulnerabilitiesFound() {
        String releaseId = "release-123";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(releaseVulnerabilityRepository).findAllByReleaseId(releaseId);
    }

    @Test
    public void getVulnerabilitiesByReleaseId_shouldReturnVulnerabilitiesWhenFound() {
        String releaseId = "release-123";

        org.frankframework.insights.vulnerability.Vulnerability vuln1 =
                new org.frankframework.insights.vulnerability.Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        vuln1.setSeverity(VulnerabilitySeverity.HIGH);
        vuln1.setCvssScore(VulnerabilitySeverity.HIGH.getRepresentativeScore());
        vuln1.setDescription("Test vulnerability 1");

        org.frankframework.insights.vulnerability.Vulnerability vuln2 =
                new org.frankframework.insights.vulnerability.Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        vuln2.setSeverity(VulnerabilitySeverity.CRITICAL);
        vuln2.setCvssScore(VulnerabilitySeverity.CRITICAL.getRepresentativeScore());
        vuln2.setDescription("Test vulnerability 2");

        Release release = new Release();
        release.setId(releaseId);

        ReleaseVulnerability rv1 = new ReleaseVulnerability(release, vuln1);
        ReleaseVulnerability rv2 = new ReleaseVulnerability(release, vuln2);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(rv1, rv2));

        VulnerabilityResponse response1 = new VulnerabilityResponse(
                "CVE-2023-0001",
                VulnerabilitySeverity.HIGH,
                VulnerabilitySeverity.HIGH.getRepresentativeScore(),
                "Test vulnerability 1",
                null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002",
                VulnerabilitySeverity.CRITICAL,
                VulnerabilitySeverity.CRITICAL.getRepresentativeScore(),
                "Test vulnerability 2",
                null);

        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(2, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        verify(releaseVulnerabilityRepository).findAllByReleaseId(releaseId);
        verify(mapper).toDTO(vuln1, VulnerabilityResponse.class);
        verify(mapper).toDTO(vuln2, VulnerabilityResponse.class);
    }

    @Test
    public void getVulnerabilitiesByReleaseId_shouldReturnUniqueVulnerabilities() {
        String releaseId = "release-123";

        org.frankframework.insights.vulnerability.Vulnerability vuln1 =
                new org.frankframework.insights.vulnerability.Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        vuln1.setSeverity(VulnerabilitySeverity.HIGH);
        vuln1.setCvssScore(VulnerabilitySeverity.HIGH.getRepresentativeScore());

        Release release = new Release();
        release.setId(releaseId);

        ReleaseVulnerability rv1 = new ReleaseVulnerability(release, vuln1);
        ReleaseVulnerability rv2 = new ReleaseVulnerability(release, vuln1);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(rv1, rv2));

        VulnerabilityResponse response1 = new VulnerabilityResponse(
                "CVE-2023-0001",
                VulnerabilitySeverity.HIGH,
                VulnerabilitySeverity.HIGH.getRepresentativeScore(),
                "Test",
                null);
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(releaseVulnerabilityRepository).findAllByReleaseId(releaseId);
    }

    @Test
    public void getVulnerabilitiesByReleaseId_shouldHandleMappingExceptions() {
        String releaseId = "release-123";

        org.frankframework.insights.vulnerability.Vulnerability vuln1 =
                new org.frankframework.insights.vulnerability.Vulnerability();
        vuln1.setCveId("CVE-2023-0001");

        Release release = new Release();
        release.setId(releaseId);

        ReleaseVulnerability rv1 = new ReleaseVulnerability(release, vuln1);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(rv1));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenThrow(new RuntimeException("Mapping failed"));

        try {
            vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);
        } catch (RuntimeException e) {
            assertEquals("Mapping failed", e.getMessage());
        }

        verify(releaseVulnerabilityRepository).findAllByReleaseId(releaseId);
    }
}
