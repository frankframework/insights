package org.frankframework.insights.vulnerability;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anySet;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockConstruction;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.common.mapper.MappingException;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedConstruction;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;

    @Mock
    private ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    @Mock
    private ReleaseRepository releaseRepository;

    @Mock
    private ReleaseArtifactService releaseArtifactService;

    @Mock
    private Mapper mapper;

    @InjectMocks
    private VulnerabilityService vulnerabilityService;

    @Captor
    private ArgumentCaptor<Set<Vulnerability>> vulnerabilitiesCaptor;

    @Captor
    private ArgumentCaptor<List<ReleaseVulnerability>> linksCaptor;

    @TempDir
    private Path tempDir;

    private Release release;

    @BeforeEach
    public void setUp() {
        ReflectionTestUtils.setField(vulnerabilityService, "trivyExecutable", "trivy");

        release = new Release();
        release.setId("release-1");
        release.setName("Test Release");
        release.setTagName("v1.0.0");
    }

    @AfterEach
    public void tearDown() {
        Thread.interrupted();
    }

    @Test
    public void testScanAll_NoReleases() throws IOException, InterruptedException {
        when(releaseRepository.findAll()).thenReturn(Collections.emptyList());

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseRepository).findAll();
        verify(releaseArtifactService, never()).prepareReleaseArtifacts(any());
    }

    @Test
    public void testScanAll_ReleaseWithNoTag() throws IOException, InterruptedException {
        Release noTagRelease = new Release();
        noTagRelease.setName("No Tag");
        when(releaseRepository.findAll()).thenReturn(new java.util.ArrayList<>(List.of(noTagRelease)));

        VulnerabilityService spyService = spy(vulnerabilityService);

        spyService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseRepository).findAll();
        verify(spyService, never()).scanAndSaveVulnerabilitiesForSingleRelease(any());
    }

    @Test
    public void testScanAll_HandlesScanExceptionAndContinues() throws Exception {
        Release release1 = new Release();
        release1.setName("Release 1");
        release1.setTagName("v1");
        Release release2 = new Release();
        release2.setName("Release 2");
        release2.setTagName("v2");
        when(releaseRepository.findAll()).thenReturn(new java.util.ArrayList<>(List.of(release1, release2)));

        VulnerabilityService spyService = spy(vulnerabilityService);
        doThrow(new IOException("Scan failed")).when(spyService).scanAndSaveVulnerabilitiesForSingleRelease(release1);
        doReturn(0).when(spyService).scanAndSaveVulnerabilitiesForSingleRelease(release2);

        spyService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(spyService, times(1)).scanAndSaveVulnerabilitiesForSingleRelease(release1);
        verify(spyService, times(1)).scanAndSaveVulnerabilitiesForSingleRelease(release2);
    }

    @Test
    public void testScanAll_HandlesInterruptedException() throws Exception {
        Release release1 = new Release();
        release1.setName("Release 1");
        release1.setTagName("v1");
        Release release2 = new Release();
        release2.setName("Release 2");
        release2.setTagName("v2");
        when(releaseRepository.findAll()).thenReturn(new java.util.ArrayList<>(List.of(release1, release2)));

        VulnerabilityService spyService = spy(vulnerabilityService);
        doThrow(new InterruptedException()).when(spyService).scanAndSaveVulnerabilitiesForSingleRelease(release1);

        spyService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(spyService, times(1)).scanAndSaveVulnerabilitiesForSingleRelease(release1);
        verify(spyService, never()).scanAndSaveVulnerabilitiesForSingleRelease(release2);
        assertTrue(Thread.currentThread().isInterrupted());
    }

    /**
     * Mocks the construction of ProcessBuilder to return a mock Process.
     * @param exitCode The exit code the mock process should return.
     * @param output The string output the process should return via its InputStream.
     * @return A MockedConstruction object to be closed by the caller.
     */
    private MockedConstruction<ProcessBuilder> mockTrivyProcess(int exitCode, String output)
            throws InterruptedException {
        Process processMock = mock(Process.class);
        when(processMock.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processMock.exitValue()).thenReturn(exitCode);
        when(processMock.getInputStream()).thenAnswer(inv -> new ByteArrayInputStream(output.getBytes()));

        return mockConstruction(ProcessBuilder.class, (mock, context) -> {
            when(mock.start()).thenReturn(processMock);
        });
    }

    @Test
    public void testScanSingle_Success_FindsVulnerabilities() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = getValidReport();
        TrivyReport report = getValidReportObject();

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.findAllById(any())).thenReturn(Collections.emptyList());
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));
        when(releaseRepository.save(any(Release.class))).thenReturn(release);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);

            assertEquals(2, links);
        }

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId(release.getId());
        verify(vulnerabilityRepository).saveAll(vulnerabilitiesCaptor.capture());
        verify(releaseVulnerabilityRepository).saveAll(linksCaptor.capture());

        assertEquals(2, vulnerabilitiesCaptor.getValue().size());
        assertEquals(2, linksCaptor.getValue().size());

        Vulnerability cve1 = vulnerabilitiesCaptor.getValue().stream()
                .filter(v -> v.getCveId().equals("CVE-2023-1234"))
                .findFirst()
                .orElse(null);
        assertNotNull(cve1);
        assertEquals("Critical Vuln | Details...", cve1.getDescription());
        assertEquals(VulnerabilitySeverity.CRITICAL, cve1.getSeverity());
        assertEquals(9.8, cve1.getCvssScore());
        assertTrue(cve1.getCwes().contains("CWE-89"));
    }

    @Test
    public void testScanSingle_Success_NoVulnerabilities() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = "{ \"Results\": [] }";
        TrivyReport report = new TrivyReport();
        report.Results = new java.util.ArrayList<>();

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(releaseRepository.save(any(Release.class))).thenReturn(release);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
            assertEquals(0, links);
        }

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId(release.getId());
        verify(vulnerabilityRepository, never()).saveAll(any());
        verify(releaseVulnerabilityRepository, never()).saveAll(any());
    }

    @Test
    public void testScanSingle_Success_UpdatesExistingVulnerability() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = getValidReport();
        TrivyReport report = getValidReportObject();

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId("CVE-2023-1234");
        existingVuln.setSeverity(VulnerabilitySeverity.MEDIUM);
        existingVuln.setDescription("Old Description");
        existingVuln.setCvssScore(5.0);

        when(vulnerabilityRepository.findAllById(any(Set.class))).thenReturn(List.of(existingVuln));
        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));
        when(releaseRepository.save(any(Release.class))).thenReturn(release);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
        }

        verify(vulnerabilityRepository).saveAll(vulnerabilitiesCaptor.capture());
        assertEquals(2, vulnerabilitiesCaptor.getValue().size());

        Vulnerability updatedVuln = vulnerabilitiesCaptor.getValue().stream()
                .filter(v -> v.getCveId().equals("CVE-2023-1234"))
                .findFirst()
                .orElse(null);

        assertNotNull(updatedVuln);
        assertEquals("Critical Vuln | Details...", updatedVuln.getDescription());
        assertEquals(VulnerabilitySeverity.CRITICAL, updatedVuln.getSeverity());
        assertEquals(9.8, updatedVuln.getCvssScore());
    }

    @Test
    public void testScanSingle_TrivyReturnsNullResults() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = "{ \"Results\": null }";
        TrivyReport report = new TrivyReport();
        report.Results = null;

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(releaseRepository.save(any(Release.class))).thenReturn(release);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
            assertEquals(0, links);
        }

        verify(releaseVulnerabilityRepository).deleteAllByReleaseId(release.getId());
        verify(vulnerabilityRepository, never()).saveAll(any());
    }

    @Test
    public void testScanSingle_TrivyScanFails_NonZeroExit() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String errorOutput = "Error: Failed to scan";

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(1, errorOutput)) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));

            assertEquals(errorOutput, e.getMessage());
        }

        verify(mapper, never()).fromJson(any(), any());
    }

    @Test
    public void testScanSingle_TrivyScanTimesOut() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        Process processMock = mock(Process.class);
        when(processMock.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(false); // Simulate timeout
        when(processMock.getInputStream()).thenReturn(new ByteArrayInputStream("".getBytes()));

        try (MockedConstruction<ProcessBuilder> ignored = mockConstruction(
                ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processMock))) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertTrue(e.getMessage().contains("Trivy scan timed out"));
        }
    }

    @Test
    public void testScanSingle_JsonParsingFails() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String invalidJson = "this is not json";

        doThrow(new MappingException("Failed to parse", null)).when(mapper).fromJson(invalidJson, TrivyReport.class);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, invalidJson)) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertTrue(e.getMessage().contains("Failed to parse Trivy JSON output"));
        }
    }

    @Test
    public void testScanSingle_RetryOnDatabaseLock_Succeeds() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String lockError = "database is locked";
        String trivyJson = getValidReport();
        TrivyReport report = getValidReportObject();

        Process processMock = mock(Process.class);
        when(processMock.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processMock.exitValue()).thenReturn(1, 0);
        when(processMock.getInputStream())
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()))
                .thenAnswer(inv -> new ByteArrayInputStream(trivyJson.getBytes()));

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));
        when(releaseRepository.save(any(Release.class))).thenReturn(release);

        try (MockedConstruction<ProcessBuilder> mockedBuilder = mockConstruction(
                ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processMock))) {
            int links = vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
            assertEquals(2, links);

            assertEquals(2, mockedBuilder.constructed().size());
            verify(mockedBuilder.constructed().get(0), times(1)).start();
            verify(mockedBuilder.constructed().get(1), times(1)).start();
            verify(processMock, times(2)).exitValue();
        }
    }

    @Test
    public void testScanSingle_RetryOnDatabaseLock_FailsAllAttempts() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String lockError = "database is locked";

        Process processFail = mock(Process.class);
        when(processFail.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processFail.exitValue()).thenReturn(1);
        when(processFail.getInputStream())
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()))
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()))
                .thenAnswer(inv -> new ByteArrayInputStream(lockError.getBytes()));

        try (MockedConstruction<ProcessBuilder> mockedBuilder = mockConstruction(
                ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processFail))) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertTrue(e.getMessage().contains("Trivy scan failed after 3 attempts"));

            assertEquals(3, mockedBuilder.constructed().size());
            mockedBuilder.constructed().forEach(mock -> {
                try {
                    verify(mock, times(1)).start();
                } catch (IOException ex) {
                    throw new RuntimeException(ex);
                }
            });
        }
    }

    @Test
    public void testScanSingle_NonLockError_FailsImmediately() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);
        String otherError = "some other error";

        Process processFail = mock(Process.class);
        when(processFail.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true);
        when(processFail.exitValue()).thenReturn(1);
        when(processFail.getInputStream()).thenAnswer(inv -> new ByteArrayInputStream(otherError.getBytes()));

        try (MockedConstruction<ProcessBuilder> mockedBuilder = mockConstruction(
                ProcessBuilder.class, (mock, context) -> when(mock.start()).thenReturn(processFail))) {
            IOException e = assertThrows(
                    IOException.class, () -> vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release));
            assertEquals(otherError, e.getMessage());

            assertEquals(1, mockedBuilder.constructed().size());
            verify(mockedBuilder.constructed().getFirst(), times(1)).start();
        }
    }

    @Test
    public void testGetVulnerabilities_Success() {
        String releaseId = "release-123";
        Vulnerability vuln = new Vulnerability();
        vuln.setCveId("CVE-2023-0001");
        ReleaseVulnerability link = new ReleaseVulnerability(release, vuln);
        VulnerabilityResponse response =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link));
        when(mapper.toDTO(vuln, VulnerabilityResponse.class)).thenReturn(response);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.contains(response));
    }

    @Test
    public void testGetVulnerabilities_NoLinks() {
        String releaseId = "release-456";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetVulnerabilities_NullOrBlankId() {
        Set<VulnerabilityResponse> resultNull = vulnerabilityService.getVulnerabilitiesByReleaseId(null);
        assertTrue(resultNull.isEmpty());

        Set<VulnerabilityResponse> resultBlank = vulnerabilityService.getVulnerabilitiesByReleaseId("  ");
        assertTrue(resultBlank.isEmpty());

        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void testGetVulnerabilities_RepoThrowsException() {
        String releaseId = "release-ex";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testMapping_ScorePriority_And_ExistingScore() throws Exception {
        when(releaseArtifactService.prepareReleaseArtifacts(release)).thenReturn(tempDir);

        String trivyJson = getComplexScoreReport();
        TrivyReport report = getComplexScoreReportObject();

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId("CVE-EXISTING");
        existingVuln.setCvssScore(5.5);

        when(vulnerabilityRepository.findAllById(anySet())).thenReturn(List.of(existingVuln));

        doReturn(report).when(mapper).fromJson(trivyJson, TrivyReport.class);
        when(vulnerabilityRepository.saveAll(anyCollection()))
                .thenAnswer(inv -> new java.util.ArrayList<>(inv.getArgument(0)));
        when(releaseVulnerabilityRepository.saveAll(anyCollection())).thenAnswer(inv -> inv.getArgument(0));
        when(releaseRepository.save(any(Release.class))).thenReturn(release);

        try (MockedConstruction<ProcessBuilder> ignored = mockTrivyProcess(0, trivyJson)) {
            vulnerabilityService.scanAndSaveVulnerabilitiesForSingleRelease(release);
        }

        verify(vulnerabilityRepository).saveAll(vulnerabilitiesCaptor.capture());
        Map<String, Vulnerability> savedVulns =
                vulnerabilitiesCaptor.getValue().stream().collect(Collectors.toMap(Vulnerability::getCveId, v -> v));

        assertEquals(5, savedVulns.size());

        assertEquals(9.8, savedVulns.get("CVE-NVD-V3").getCvssScore());
        assertEquals(9.1, savedVulns.get("CVE-RH-V3").getCvssScore());
        assertEquals(7.5, savedVulns.get("CVE-V2-ONLY").getCvssScore());
        assertEquals(5.5, savedVulns.get("CVE-NO-SCORE").getCvssScore());
        assertEquals(5.5, savedVulns.get("CVE-EXISTING").getCvssScore());
    }

    private String getValidReport() {
        return "{\"Results\":[{\"Target\":\"pom.xml\",\"Vulnerabilities\":[{\"VulnerabilityID\":\"CVE-2023-1234\",\"Title\":\"Critical Vuln\",\"Description\":\"Details...\",\"Severity\":\"CRITICAL\",\"CweIDs\":[\"CWE-89\"],\"CVSS\":{\"nvd\":{\"V3Score\":9.8}}},{\"VulnerabilityID\":\"CVE-2023-5678\",\"Title\":\"High Vuln\",\"Description\":\"Details...\",\"Severity\":\"HIGH\",\"CVSS\":{\"redhat\":{\"V2Score\":7.5}}}]}]}";
    }

    private TrivyReport getValidReportObject() {
        TrivyReport report = new TrivyReport();

        TrivyCvssScore cve1Score = new TrivyCvssScore(null, null, 9.8, null);
        TrivyVulnerability cve1 = new TrivyVulnerability(
                "CVE-2023-1234",
                "Critical Vuln",
                "Details...",
                "CRITICAL",
                List.of("CWE-89"),
                Map.of("nvd", cve1Score));

        TrivyCvssScore cve2Score = new TrivyCvssScore(7.5, null, null, null);
        TrivyVulnerability cve2 = new TrivyVulnerability(
                "CVE-2023-5678", "High Vuln", "Details...", "HIGH", null, Map.of("redhat", cve2Score));

        TrivyResult result = new TrivyResult("pom.xml", null, null, List.of(cve1, cve2));

        report.Results = List.of(result);
        return report;
    }

    /**
     * Provides a complex JSON report for testing CVSS score selection.
     * THIS MUST BE A SINGLE LINE.
     */
    private String getComplexScoreReport() {
        return "{\"Results\":[{\"Vulnerabilities\":[{\"VulnerabilityID\":\"CVE-NVD-V3\",\"Severity\":\"CRITICAL\",\"CVSS\":{\"nvd\":{\"V3Score\":9.8},\"redhat\":{\"V3Score\":9.1}}},{\"VulnerabilityID\":\"CVE-RH-V3\",\"Severity\":\"CRITICAL\",\"CVSS\":{\"redhat\":{\"V3Score\":9.1},\"other\":{\"V2Score\":7.5}}},{\"VulnerabilityID\":\"CVE-V2-ONLY\",\"Severity\":\"HIGH\",\"CVSS\":{\"other\":{\"V2Score\":7.5}}},{\"VulnerabilityID\":\"CVE-NO-SCORE\",\"Severity\":\"MEDIUM\",\"CVSS\":{}},{\"VulnerabilityID\":\"CVE-EXISTING\",\"Severity\":\"MEDIUM\",\"CVSS\":{}}]}]}";
    }

    private TrivyReport getComplexScoreReportObject() {
        TrivyReport report = new TrivyReport();

        TrivyVulnerability v1 = new TrivyVulnerability(
                "CVE-NVD-V3",
                null,
                null,
                "CRITICAL",
                null,
                Map.of(
                        "nvd",
                        new TrivyCvssScore(null, null, 9.8, null),
                        "redhat",
                        new TrivyCvssScore(null, null, 9.1, null)));
        TrivyVulnerability v2 = new TrivyVulnerability(
                "CVE-RH-V3",
                null,
                null,
                "CRITICAL",
                null,
                Map.of(
                        "redhat",
                        new TrivyCvssScore(null, null, 9.1, null),
                        "other",
                        new TrivyCvssScore(7.5, null, null, null)));
        TrivyVulnerability v3 = new TrivyVulnerability(
                "CVE-V2-ONLY", null, null, "HIGH", null, Map.of("other", new TrivyCvssScore(7.5, null, null, null)));
        TrivyVulnerability v4 =
                new TrivyVulnerability("CVE-NO-SCORE", null, null, "MEDIUM", null, Collections.emptyMap());
        TrivyVulnerability v5 =
                new TrivyVulnerability("CVE-EXISTING", null, null, "MEDIUM", null, Collections.emptyMap());

        TrivyResult result = new TrivyResult(null, null, null, List.of(v1, v2, v3, v4, v5));

        report.Results = List.of(result);
        return report;
    }

    @Test
    public void testGetAllVulnerabilities_Success() {
        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        vuln1.setSeverity(VulnerabilitySeverity.HIGH);
        vuln1.setCvssScore(7.5);

        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        vuln2.setSeverity(VulnerabilitySeverity.CRITICAL);
        vuln2.setCvssScore(9.8);

        VulnerabilityResponse response1 =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc1", null, null, null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002", VulnerabilitySeverity.CRITICAL, 9.8, "Desc2", null, null, null);

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln1, vuln2));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertEquals(2, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_EmptyList() {
        when(vulnerabilityRepository.findAll()).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_RepoThrowsException() {
        when(vulnerabilityRepository.findAll()).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testUpdateVulnerability_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(8.5, "High impact on production");

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setSeverity(VulnerabilitySeverity.HIGH);
        existingVuln.setCvssScore(7.5);
        existingVuln.setDescription("Original description");

        Vulnerability savedVuln = new Vulnerability();
        savedVuln.setCveId(cveId);
        savedVuln.setSeverity(VulnerabilitySeverity.HIGH);
        savedVuln.setCvssScore(7.5);
        savedVuln.setDescription("Original description");
        savedVuln.setImpactScore(8.5);
        savedVuln.setImpactDescription("High impact on production");

        VulnerabilityResponse expectedResponse = new VulnerabilityResponse(
                cveId, VulnerabilitySeverity.HIGH, 7.5, "Original description", null, 8.5, "High impact on production");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(java.util.Optional.of(existingVuln));
        when(vulnerabilityRepository.save(any(Vulnerability.class))).thenReturn(savedVuln);
        when(mapper.toDTO(savedVuln, VulnerabilityResponse.class)).thenReturn(expectedResponse);

        VulnerabilityResponse result = vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest);

        assertNotNull(result);
        assertEquals(cveId, result.cveId());
        assertEquals(8.5, result.impactScore());
        assertEquals("High impact on production", result.impactDescription());

        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, times(1)).save(any(Vulnerability.class));
        verify(mapper, times(1)).toDTO(savedVuln, VulnerabilityResponse.class);
    }

    @Test
    public void testUpdateVulnerability_NotFound() {
        String cveId = "CVE-NOT-EXIST";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, "Some impact");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(java.util.Optional.empty());

        VulnerabilityNotFoundException exception = assertThrows(
                VulnerabilityNotFoundException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Vulnerability not found with CVE ID: " + cveId));
        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerability_NullCveId() {
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, "Some impact");

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(null, updateRequest));

        assertTrue(exception.getMessage().contains("CVE ID cannot be null or blank"));
        verify(vulnerabilityRepository, never()).findById(any());
    }

    @Test
    public void testUpdateVulnerability_BlankCveId() {
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, "Some impact");

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact("  ", updateRequest));

        assertTrue(exception.getMessage().contains("CVE ID cannot be null or blank"));
        verify(vulnerabilityRepository, never()).findById(any());
    }

    @Test
    public void testUpdateVulnerability_WithNullImpactScore_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(null, "Some description");

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("impact score and description"));
        verify(vulnerabilityRepository, never()).findById(any());
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerability_WithNullDescription_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, null);

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("impact score and description"));
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testDeleteVulnerabilityImpact_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-DELETE";
        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(9.0);
        existingVuln.setImpactDescription("To be deleted");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(java.util.Optional.of(existingVuln));

        vulnerabilityService.deleteVulnerabilityImpact(cveId);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        assertEquals(cveId, savedVuln.getCveId());
        Assertions.assertNull(savedVuln.getImpactScore());
        Assertions.assertNull(savedVuln.getImpactDescription());
    }

    @Test
    public void testDeleteVulnerabilityImpact_NotFound() {
        String cveId = "CVE-UNKNOWN";
        when(vulnerabilityRepository.findById(cveId)).thenReturn(java.util.Optional.empty());

        assertThrows(VulnerabilityNotFoundException.class, () -> vulnerabilityService.deleteVulnerabilityImpact(cveId));

        verify(vulnerabilityRepository, never()).save(any());
    }
}
