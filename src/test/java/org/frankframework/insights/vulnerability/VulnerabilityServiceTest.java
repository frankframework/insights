package org.frankframework.insights.vulnerability;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerability;
import org.frankframework.insights.common.entityconnection.releasevulnerability.ReleaseVulnerabilityRepository;
import org.frankframework.insights.common.enums.VulnerabilitySeverity;
import org.frankframework.insights.common.mapper.Mapper;
import org.frankframework.insights.release.Release;
import org.frankframework.insights.release.ReleaseArtifactService;
import org.frankframework.insights.release.ReleaseRepository;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class VulnerabilityServiceTest {

    @Mock
    private VulnerabilityRepository vulnerabilityRepository;

    @Mock
    private ReleaseVulnerabilityRepository releaseVulnerabilityRepository;

    @Mock
    private ReleaseRepository releaseRepository;

    @Mock
    private ReleaseArtifactService releaseArtifactService;

    @Mock
    private Mapper mapper;

    private VulnerabilityService vulnerabilityService;

    private Release release;

    @BeforeEach
    public void setUp() {
        vulnerabilityService = new VulnerabilityService(
                vulnerabilityRepository,
                releaseVulnerabilityRepository,
                releaseRepository,
                releaseArtifactService,
                mapper,
                "trivy",
                "/tmp/trivy-scan",
                "/tmp/trivy-cache");

        release = new Release();
        release.setId("release-1");
        release.setName("Test Release");
        release.setTagName("v1.0.0");
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_Success() {
        String releaseId = "release-123";
        Vulnerability vuln = new Vulnerability();
        vuln.setCveId("CVE-2023-0001");
        ReleaseVulnerability link = new ReleaseVulnerability(release, vuln);
        VulnerabilityResponse response =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link));
        when(mapper.toDTO(vuln, VulnerabilityResponse.class)).thenReturn(response);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.contains(response));
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_NoLinks() {
        String releaseId = "release-456";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_NullOrBlankId() {
        Set<VulnerabilityResponse> resultNull = vulnerabilityService.getVulnerabilitiesByReleaseId(null);
        assertTrue(resultNull.isEmpty());

        Set<VulnerabilityResponse> resultBlank = vulnerabilityService.getVulnerabilitiesByReleaseId("  ");
        assertTrue(resultBlank.isEmpty());

        verify(releaseVulnerabilityRepository, never()).findAllByReleaseId(any());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_RepoThrowsException() {
        String releaseId = "release-ex";
        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testGetAllVulnerabilities_Success() {
        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        vuln1.setSeverity(VulnerabilitySeverity.HIGH);
        vuln1.setCvssScore(7.5);

        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        vuln2.setSeverity(VulnerabilitySeverity.CRITICAL);
        vuln2.setCvssScore(9.8);

        VulnerabilityResponse response1 =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc1", null, null, null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002", VulnerabilitySeverity.CRITICAL, 9.8, "Desc2", null, null, null);

        when(vulnerabilityRepository.findAll()).thenReturn(List.of(vuln1, vuln2));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertEquals(2, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_EmptyList() {
        when(vulnerabilityRepository.findAll()).thenReturn(Collections.emptyList());

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(vulnerabilityRepository, times(1)).findAll();
    }

    @Test
    public void testGetAllVulnerabilities_RepoThrowsException() {
        when(vulnerabilityRepository.findAll()).thenThrow(new RuntimeException("DB error"));

        Set<VulnerabilityResponse> result = vulnerabilityService.getAllVulnerabilities();

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testUpdateVulnerabilityImpact_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(8.5, "High impact on production");

        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setSeverity(VulnerabilitySeverity.HIGH);
        existingVuln.setCvssScore(7.5);
        existingVuln.setDescription("Original description");

        Vulnerability savedVuln = new Vulnerability();
        savedVuln.setCveId(cveId);
        savedVuln.setSeverity(VulnerabilitySeverity.HIGH);
        savedVuln.setCvssScore(7.5);
        savedVuln.setDescription("Original description");
        savedVuln.setImpactScore(8.5);
        savedVuln.setImpactDescription("High impact on production");

        VulnerabilityResponse expectedResponse = new VulnerabilityResponse(
                cveId, VulnerabilitySeverity.HIGH, 7.5, "Original description", null, 8.5, "High impact on production");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));
        when(vulnerabilityRepository.save(any(Vulnerability.class))).thenReturn(savedVuln);
        when(mapper.toDTO(savedVuln, VulnerabilityResponse.class)).thenReturn(expectedResponse);

        VulnerabilityResponse result = vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest);

        assertNotNull(result);
        assertEquals(cveId, result.cveId());
        assertEquals(8.5, result.impactScore());
        assertEquals("High impact on production", result.impactDescription());

        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, times(1)).save(any(Vulnerability.class));
        verify(mapper, times(1)).toDTO(savedVuln, VulnerabilityResponse.class);
    }

    @Test
    public void testUpdateVulnerabilityImpact_NotFound() {
        String cveId = "CVE-NOT-EXIST";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, "Some impact");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.empty());

        VulnerabilityNotFoundException exception = assertThrows(
                VulnerabilityNotFoundException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Vulnerability not found: " + cveId));
        verify(vulnerabilityRepository, times(1)).findById(cveId);
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_NullRequest_ThrowsException() {
        String cveId = "CVE-2023-1234";

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class, () -> vulnerabilityService.updateVulnerabilityImpact(cveId, null));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).findById(any());
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_WithNullImpactScore_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(null, "Some description");

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).findById(any());
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testUpdateVulnerabilityImpact_WithNullDescription_ThrowsException() {
        String cveId = "CVE-2023-1234";
        VulnerabilityImpactRequest updateRequest = new VulnerabilityImpactRequest(5.0, null);

        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> vulnerabilityService.updateVulnerabilityImpact(cveId, updateRequest));

        assertTrue(exception.getMessage().contains("Request cannot be null"));
        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testDeleteVulnerabilityImpact_Success() throws VulnerabilityNotFoundException {
        String cveId = "CVE-2023-DELETE";
        Vulnerability existingVuln = new Vulnerability();
        existingVuln.setCveId(cveId);
        existingVuln.setImpactScore(9.0);
        existingVuln.setImpactDescription("To be deleted");

        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.of(existingVuln));

        vulnerabilityService.deleteVulnerabilityImpact(cveId);

        ArgumentCaptor<Vulnerability> captor = ArgumentCaptor.forClass(Vulnerability.class);
        verify(vulnerabilityRepository).save(captor.capture());

        Vulnerability savedVuln = captor.getValue();
        assertEquals(cveId, savedVuln.getCveId());
        Assertions.assertNull(savedVuln.getImpactScore());
        Assertions.assertNull(savedVuln.getImpactDescription());
    }

    @Test
    public void testDeleteVulnerabilityImpact_NotFound() {
        String cveId = "CVE-UNKNOWN";
        when(vulnerabilityRepository.findById(cveId)).thenReturn(Optional.empty());

        assertThrows(VulnerabilityNotFoundException.class, () -> vulnerabilityService.deleteVulnerabilityImpact(cveId));

        verify(vulnerabilityRepository, never()).save(any());
    }

    @Test
    public void testGetVulnerabilitiesByReleaseId_WithMultipleVulnerabilities() {
        String releaseId = "release-multi";

        Vulnerability vuln1 = new Vulnerability();
        vuln1.setCveId("CVE-2023-0001");
        Vulnerability vuln2 = new Vulnerability();
        vuln2.setCveId("CVE-2023-0002");
        Vulnerability vuln3 = new Vulnerability();
        vuln3.setCveId("CVE-2023-0003");

        ReleaseVulnerability link1 = new ReleaseVulnerability(release, vuln1);
        ReleaseVulnerability link2 = new ReleaseVulnerability(release, vuln2);
        ReleaseVulnerability link3 = new ReleaseVulnerability(release, vuln3);

        VulnerabilityResponse response1 =
                new VulnerabilityResponse("CVE-2023-0001", VulnerabilitySeverity.HIGH, 7.5, "Desc1", null, null, null);
        VulnerabilityResponse response2 = new VulnerabilityResponse(
                "CVE-2023-0002", VulnerabilitySeverity.MEDIUM, 5.0, "Desc2", null, null, null);
        VulnerabilityResponse response3 = new VulnerabilityResponse(
                "CVE-2023-0003", VulnerabilitySeverity.CRITICAL, 9.8, "Desc3", null, null, null);

        when(releaseVulnerabilityRepository.findAllByReleaseId(releaseId)).thenReturn(List.of(link1, link2, link3));
        when(mapper.toDTO(vuln1, VulnerabilityResponse.class)).thenReturn(response1);
        when(mapper.toDTO(vuln2, VulnerabilityResponse.class)).thenReturn(response2);
        when(mapper.toDTO(vuln3, VulnerabilityResponse.class)).thenReturn(response3);

        Set<VulnerabilityResponse> result = vulnerabilityService.getVulnerabilitiesByReleaseId(releaseId);

        assertNotNull(result);
        assertEquals(3, result.size());
        assertTrue(result.contains(response1));
        assertTrue(result.contains(response2));
        assertTrue(result.contains(response3));
    }

    @Test
    public void testScanAndSaveVulnerabilitiesForAllReleases_WithNoReleases() throws IOException {
        when(releaseRepository.findAll()).thenReturn(Collections.emptyList());

        vulnerabilityService.scanAndSaveVulnerabilitiesForAllReleases();

        verify(releaseRepository, times(1)).findAll();
        verify(releaseArtifactService, never()).downloadReleaseZipToPvc(any());
    }
}
